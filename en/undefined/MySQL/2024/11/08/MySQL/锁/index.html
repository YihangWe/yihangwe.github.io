<!DOCTYPE html>
<html lang="zh-CN,en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yihangwe.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="如何在高并发访问下，既充分利用数据库的并发能力，又保证每个用户对数据的读写操作保持一致性呢？为此，数据库系统引入了锁（locking）机制，这也是它与文件系统的一个关键区别。 而且这里需要澄清，只有当系统真正需要更高锁粒度时，行级锁才会出现开销，而 InnoDB 本身并不依赖锁升级机制，因为单个锁与多个锁的成本是相当的。也就是说，在不需要非常高并发写冲突控制的情况下，InnoDB 不会主动为每一行">
<meta property="og:type" content="article">
<meta property="og:title" content="锁">
<meta property="og:url" content="https://yihangwe.github.io/en/undefined/MySQL/2024/11/08/MySQL/%E9%94%81/index.html">
<meta property="og:site_name" content="EthanWeee 的个人日志">
<meta property="og:description" content="如何在高并发访问下，既充分利用数据库的并发能力，又保证每个用户对数据的读写操作保持一致性呢？为此，数据库系统引入了锁（locking）机制，这也是它与文件系统的一个关键区别。 而且这里需要澄清，只有当系统真正需要更高锁粒度时，行级锁才会出现开销，而 InnoDB 本身并不依赖锁升级机制，因为单个锁与多个锁的成本是相当的。也就是说，在不需要非常高并发写冲突控制的情况下，InnoDB 不会主动为每一行">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://yihangwe.github.io/images/MySQL/mysql_locking_rec.drawio.png">
<meta property="og:image" content="https://yihangwe.github.io/images/MySQL/mysql_locking_gap.drawio.png">
<meta property="og:image" content="https://yihangwe.github.io/images/MySQL/mysql_locking_nxt_key.drawio.png">
<meta property="og:image" content="https://yihangwe.github.io/images/MySQL/mysql_locking_trx_lock.drawio.png">
<meta property="og:image" content="https://yihangwe.github.io/images/MySQL/mysql_locking_wait_graph.drawio.png">
<meta property="article:published_time" content="2024-11-08T16:00:00.000Z">
<meta property="article:modified_time" content="2025-06-20T22:33:51.512Z">
<meta property="article:author" content="Yihang Wei">
<meta property="article:tag" content="数据库, 分布式, OLTP, OLAP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yihangwe.github.io/images/MySQL/mysql_locking_rec.drawio.png">

<link rel="canonical" href="https://yihangwe.github.io/en/undefined/MySQL/2024/11/08/MySQL/%E9%94%81/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>锁 | EthanWeee 的个人日志</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><script>(function() {function calculateHeight(element) {let height = 0;const items = element.children;for (let i = 0; i < items.length; i++) {height += items[i].offsetHeight || 25;const child = items[i].querySelector(".nav-child");if (child && child.style.display !== "none") {height += calculateHeight(child);}}return height;}function generateToc(lang, container) {const content = document.getElementById(lang + "-content");if (!content) return;const headers = Array.from(content.querySelectorAll("h1, h2, h3, h4, h5, h6"));if (headers.length === 0) return;const ol = document.createElement("ol");ol.className = "nav";let currentLevel = 1;let currentOl = ol;let stack = [ol];let counters = [0, 0, 0, 0, 0, 0];headers.forEach((header, index) => {const level = parseInt(header.tagName[1]);counters[level - 1]++;for (let i = level; i < 6; i++) counters[i] = 0;const li = document.createElement("li");li.className = "nav-item nav-level-" + level;if (level === 1 && index === 0) {li.classList.add("active", "active-current");}const link = document.createElement("a");link.className = "nav-link";if (level === 1 && index === 0) link.classList.add("active");link.href = "#" + header.id;const numSpan = document.createElement("span");numSpan.className = "nav-number";numSpan.textContent = counters.slice(0, level).filter(n => n > 0).join(".");const textSpan = document.createElement("span");textSpan.className = "nav-text";textSpan.textContent = header.textContent;link.appendChild(numSpan);link.appendChild(document.createTextNode(" "));link.appendChild(textSpan);li.appendChild(link);if (level > currentLevel) {const newOl = document.createElement("ol");newOl.className = "nav-child";if (currentLevel === 1) {newOl.style.display = "block";stack[currentLevel - 1].lastElementChild.classList.add("active");}stack[currentLevel - 1].lastElementChild.appendChild(newOl);stack[level - 1] = newOl;currentOl = newOl;} else if (level < currentLevel) {currentOl = stack[level - 1];}currentOl.appendChild(li);currentLevel = level;});container.appendChild(ol);setTimeout(() => {const navHeight = calculateHeight(ol);ol.style.setProperty("--height", navHeight + "px");const navChilds = ol.getElementsByClassName("nav-child");Array.from(navChilds).forEach(child => {if (child.style.display === "block") {const childHeight = calculateHeight(child);child.style.setProperty("--height", childHeight + "px");}});}, 0);return ol;}function updateActiveHeading() {const activeLang = document.getElementById("en-content").style.display === "block" ? "en" : "zh";const content = document.getElementById(activeLang + "-content");const toc = document.getElementById(activeLang + "-toc");if (!content || !toc) return;const headers = Array.from(content.querySelectorAll("h1, h2, h3, h4, h5, h6"));const scrollPos = window.scrollY + window.innerHeight / 3;let activeHeader = null;for (let i = headers.length - 1; i >= 0; i--) {const header = headers[i];const headerTop = header.getBoundingClientRect().top + window.scrollY;if (headerTop <= scrollPos) {activeHeader = header;break;}}const links = toc.getElementsByClassName("nav-link");Array.from(links).forEach(link => {link.classList.remove("active");const parentLi = link.parentElement;if (parentLi) {parentLi.classList.remove("active", "active-current");}});if (activeHeader) {const activeLink = toc.querySelector(`a[href="#${activeHeader.id}"]`);if (activeLink) {activeLink.classList.add("active");let parent = activeLink.parentElement;while (parent && parent.classList) {if (parent.classList.contains("nav-item")) {parent.classList.add("active");if (parent.classList.contains("nav-level-1")) {parent.classList.add("active-current");}}parent = parent.parentElement;}}}}function initTippy() {document.querySelectorAll(".refplus-num").forEach((ref) => {if (ref._tippy) {ref._tippy.destroy();}let refid = ref.firstChild.href.replace(location.origin+location.pathname,"");let refel = document.querySelector(refid);if (!refel) return;let refnum = refel.dataset.num;let ref_content = refel.innerText.replace(`[${refnum}]`,"");tippy(ref, {content: ref_content,});});}function initToc() {const originalToc = document.querySelector(".post-toc-wrap");if (!originalToc || !document.getElementById("langToggle")) return;const tocContainer = document.createElement("div");tocContainer.className = "post-toc-wrap sidebar-panel sidebar-panel-active";const enToc = document.createElement("div");enToc.id = "en-toc";enToc.className = "post-toc motion-element";enToc.style.display = "block";const zhToc = document.createElement("div");zhToc.id = "zh-toc";zhToc.className = "post-toc motion-element";zhToc.style.display = "none";generateToc("en", enToc);generateToc("zh", zhToc);tocContainer.appendChild(enToc);tocContainer.appendChild(zhToc);originalToc.parentNode.replaceChild(tocContainer, originalToc);window.addEventListener("scroll", updateActiveHeading);setTimeout(updateActiveHeading, 0);}window.toggleLanguage = function() {const enContent = document.getElementById("en-content");const zhContent = document.getElementById("zh-content");const enToc = document.getElementById("en-toc");const zhToc = document.getElementById("zh-toc");const button = document.getElementById("langToggle");if (!enContent || !zhContent || !enToc || !zhToc || !button) return;const isEnglish = enContent.style.display === "block";enContent.style.display = isEnglish ? "none" : "block";zhContent.style.display = isEnglish ? "block" : "none";enToc.style.display = isEnglish ? "none" : "block";zhToc.style.display = isEnglish ? "block" : "none";button.querySelector(".button-text").textContent = isEnglish ? "Switch to English" : "切换中文";setTimeout(updateActiveHeading, 0);setTimeout(initTippy, 100);};document.addEventListener("DOMContentLoaded", function() {initToc();setTimeout(initTippy, 3000);});})();</script><style>.post-toc { transition: all 0.2s ease-in-out; }.post-toc .nav { padding-left: 0; }.post-toc .nav-child { padding-left: 1em; }.post-toc .nav-item { line-height: 1.8; }.post-toc .nav-link { color: #555; }.post-toc .nav-link:hover { color: #222; }.post-toc .nav-link.active { color: #fc6423; }.post-toc .active > .nav-link { color: #fc6423; }.post-toc .active-current > .nav-link { color: #fc6423; }</style><!-- hexo injector head_end end --><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EthanWeee 的个人日志</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/MySQL/2024/11/08/MySQL/%E9%94%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee 的个人日志">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          锁
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2024-11-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-09T00:00:00+08:00">2024-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-21 06:33:51" itemprop="dateModified" datetime="2025-06-21T06:33:51+08:00">2025-06-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><p>如何在高并发访问下，既充分利用数据库的并发能力，又保证每个用户对数据的读写操作保持一致性呢？为此，数据库系统引入了锁（locking）机制，这也是它与文件系统的一个关键区别。</p>
<p>而且这里需要澄清，只有当系统真正需要更高锁粒度时，行级锁才会出现开销，而 InnoDB 本身并不依赖锁升级机制，因为单个锁与多个锁的成本是相当的。也就是说，在不需要非常高并发写冲突控制的情况下，InnoDB 不会主动为每一行都添加行锁；只有当真的有并发冲突需要保护同一行时，才会产生行级锁对应的数据结构开销。</p>
<p>锁是计算机中协调多个进程或线程并发访问某一资源的机制。</p>
<p>在MySQL中，事务中的锁（行锁、表锁等）会一直保留到事务结束（COMMIT 或 ROLLBACK）。</p>
<h2 id="lock-与-latch"><a href="#lock-与-latch" class="headerlink" title="lock 与 latch"></a>lock 与 latch</h2><ol>
<li>Latch（闩锁）<ul>
<li>也称为轻量级锁或临界区锁，主要用于保护数据库内部的临时数据结构与内存资源，确保多个线程在访问或修改同一份临界资源时不会产生并发安全问题。</li>
<li>必须保证其持有时间极短：一旦线程完成对临界资源的访问，必须立即释放 latch，否则会严重影响整个系统的并发性能。</li>
<li>在 InnoDB 存储引擎内部，latch 进一步分为两类：<ul>
<li>Mutex（互斥量）：最简单的二元互斥锁，用于保护对某个共享资源的独占访问。</li>
<li>RWLock（读写锁）：允许多个读线程同时进入临界区，但写线程独占，保证读写操作对同一资源的并发正确性。</li>
</ul>
</li>
<li>无死锁检测：由于 latch 的持有时间极短，InnoDB 不会对其进行死锁检测。一旦某线程在短时间内未能获取到 latch，往往是因为有其他线程暂时占用，系统会进行短暂等待或重试，直到拿到 latch 才继续执行。</li>
</ul>
</li>
<li>Lock（事务锁）<ul>
<li>针对数据库对象（如表、页、行）而设计，由事务进行获取和释放：<ul>
<li>加锁操作（例如加行锁、页锁）只会在事务提交（COMMIT）或回滚（ROLLBACK）时才被释放（不同的隔离级别下，锁的释放时机可能会有所区别）。</li>
<li>Lock 的持有时间较长（往往跨越整个事务执行过程），因此对并发冲突的检测和处理必须更完整。</li>
</ul>
</li>
<li>支持死锁检测与处理：当多个事务彼此等待对方持有的锁而陷入循环等待时，InnoDB 会自动检测死锁并选择性地回滚某个事务以打破循环，从而保证系统不会长期阻塞。</li>
<li>锁级别包括：意向锁（Intention Lock）、行级锁（Record Lock）、间隙锁（Gap Lock）、次序锁（Next-Key Lock）等，它们共同配合以实现更高效、更细粒度的并发控制。</li>
</ul>
</li>
</ol>
<h2 id="锁问题"><a href="#锁问题" class="headerlink" title="锁问题"></a>锁问题</h2><p>通过锁定机制可以实现事务的隔离性要求，使得事务可以并发地工作。锁提高了并发，但是却会带来潜在的问题。不过好在因为事务隔离性的要求，锁只会带来三种问题，如果可以防止这三种情况的发生，那将不会产生并发异常。</p>
<h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>在理解脏读（Dirty Read）之前，需要理解脏数据的概念。但是脏数据和之前所介绍的脏页完全是两种不同的概念。脏页指的是在缓冲池中已经被修改的页，但是还没有刷新到磁盘中，即数据库实例内存中的页和磁盘中的页的数据是不一致的，当然在刷新到磁盘之前，日志也已经被写入到了重做日志文件中。而所谓脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交（commit）。</p>
<p>对于脏页的读取，是非常正常的。脏页是因为数据库实例内存和磁盘的异步造成的，这并不影响数据的一致性（或者说两者最终会达到一致，即当脏页都刷新到磁盘）。并且因为脏页的刷新是异步的，不影响数据库的可用性，因此可以带来性能的提高。</p>
<p>脏数据却截然不同，脏数据是指未提交的数据，如果读到脏数据，即一个事务可以读取到另外一个事务中未提交的数据，则显然违反了数据库的隔离性。</p>
<p>脏读指的就是在不同的事务下，当前事务可以读到另外事务未提交的数据，简单来说就是可以读到脏数据。</p>
<p>脏读发生的条件是需要事务的隔离级别为 READ UNCOMMITTED，而目前绝大部分的数据库都会至少设置成 READ COMMITTED。InnoDB 存储引擎默认的事务隔离级别为 REPEATABLE READ，Microsoft SQL Server 数据库为 READ COMMITTED，Oracle 数据库同样也是 READ COMMITTED。</p>
<blockquote>
<p>[!NOTE]</p>
<p>关于 InnoDB 默认采用 RR 隔离级别的原因可参考：<a href="/MySQL/2024/10/28/MySQL/%E6%96%87%E4%BB%B6/#why_rr">为什么 InnoDB 默认采用 RR 隔离级别？</a></p>
</blockquote>
<p>脏读隔离看似毫无用处，但在一些比较特殊的情况下还是可以将事务的隔离级别设置为 READ UNCOMMITTED。例如 replication 环境中的 slave 节点，并且在该 slave 上的查询并不需要特别精确的返回值。</p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>不可重复读指在同一个事务（会话）内多次读取同一数据集时，由于另一个事务对该数据集进行了 DML 修改（插入、更新或删除），导致第一次和第二次读取的结果不一致。换句话说，同一事务中对同一行数据执行两次 SELECT 查询，若中间有其他事务提交了修改，使得这两次查询得到不同的数据，就发生了不可重复读。</p>
<p>大多数数据库（如 Oracle、Microsoft SQL Server、PostgreSQL 等）在默认隔离级别为 READ COMMITTED 时，允许发生不可重复读，因为读取的是已提交数据，一般被认为可接受，不会引起严重一致性问题。</p>
<p>InnoDB 存储引擎默认隔离级别是 REPEATABLE READ，在该级别下使用 Next-Key Locking（锁定索引记录本身以及其前一个 gap 范围）来防止不可重复读和幻读。</p>
<ul>
<li>当事务第一次扫描索引行时，会对这条数据及其相邻的 gap 区间加锁，阻止其他事务在该范围内插入或修改行。</li>
<li>因此，同一事务的后续读取始终只能看到最初加锁时的“快照”数据，不会因他人提交修改而改变读取结果。</li>
</ul>
<p>若将隔离级别设置为 READ COMMITTED，InnoDB 只对具体记录加行锁（Record Lock），不再对 gap 进行加锁，因此允许在两次读取之间对行或 gap 进行插入&#x2F;更新，从而出现不可重复读。</p>
<h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p>丢失更新指的是：当两个事务（或两个并发操作）都希望修改同一行数据时，后提交的那个更新“覆盖”了先提交的更新，导致先前的修改最终没有被保存，从而出现数据不一致。例如：</p>
<ol>
<li>事务 T1 将行记录 r 更新为 v1，但是事务 T1 并未提交。</li>
<li>与此同时，事务 T2 将行记录 r 更新为 v2，事务 T2 未提交。</li>
<li>事务 T1 提交。</li>
<li>事务 T2 提交。</li>
</ol>
<p>但是，在当前数据库的任何隔离级别下，都不会导致数据库理论意义上的丢失更新问题。这是因为，即使是 READ UNCOMMITTED 的事务隔离级别，对于行的 DML 操作，需要对行或其他粗粒度级别的对象加锁。因此在上述步骤 2) 中，事务 T2 并不能对行记录 r 进行更新操作，其会被阻塞，直到事务 T1 提交。</p>
<p>虽然数据库能阻止丢失更新问题的产生，但是在生产应用中还有另一个逻辑意义的丢失更新问题，而导致该问题的并不是因为数据库本身的问题。实际上，在所有多用户计算机系统环境下都可能产生这个问题。简单地说来，出现下面的情况时，就会发生丢失更新：</p>
<ol>
<li>事务 T1 查询一行数据，放入本地内存，并显示给一个终端用户 User1。</li>
<li>事务 T2 也查询该行数据，并将取得的数据显示给终端用户 User2。</li>
<li>User1 修改该行记录，更新数据库并提交。</li>
<li>User2 修改该行记录，更新数据库并提交。</li>
</ol>
<p>显然，这个过程中用户 User1 的修改更新操作丢失了，而这可能会导致一个恐怖的结果。设想银行发生丢失更新现象，例如一个用户账号中有 10000 元人民币，他用两个网上银行的客户端分别进行转账操作。第一次转账 9000 人民币，因为网络和数据的关系，这时需要等待。但是这时用户操作另一个网上银行客户端，转账 1 元，如果最终两个转账都成功了，用户的帐号余额是 9999 人民币，第一次转的 9000 人民币并没有得到更新，但是在转账的另一个账户却会收到这 9000 元，这导致的结果就是钱变多，而账不平。</p>
<p>这里需要澄清的是，以上银行问题的发生和数据库无关，而是业务逻辑的问题。</p>
<p>也就是说，如果我们直接写 <code>UPDATE account SET cash = cash - 9000 WHERE user = pUser;</code>，那么 InnoDB 会对满足 <code>user = pUser</code> 的那一行加 X 锁，保证同时不会有别的事务也在修改它。但在很多业务里，我们并不能“直接更新”——往往要先读余额（SELECT），做业务判断（比如余额是否足够、是否与外部系统交互等），然后再走 UPDATE。<strong>在你只使用普通的</strong> <strong>SELECT …</strong> <strong>而没有加锁（FOR UPDATE）时，数据库不会对这条记录加行级排他锁</strong>，这时别的事务就可能同时也读到同一个旧余额，然后各自计算完毕后分别执行 UPDATE，造成后面那笔更新把前面那笔更新覆盖——这才是真正的丢失更新。</p>
<p>要避免丢失更新发生，需要让事务在这种情况下的操作变成串行化，而不是并行的操作。即在上述四个步骤的 1) 中，对用户读取的记录加上一个排他 X 锁。同样，在步骤 2) 的操作过程中，用户同样也需要加一个排他 X 锁。通过这种方式，步骤 2) 就必须等待 1) 和 3) 完成，最后完成步骤 4)。</p>
<h2 id="InnoDB-存储引擎中的锁"><a href="#InnoDB-存储引擎中的锁" class="headerlink" title="InnoDB 存储引擎中的锁"></a>InnoDB 存储引擎中的锁</h2><h3 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h3><p><strong>按照兼容性可分为：</strong></p>
<ul>
<li>共享锁（S Lock），允许事务读一行数据。</li>
<li>排他锁（X Lock），允许事务删除或更新一行数据。</li>
</ul>
<p>如果一个事务 T1 已经获得了 r 行的共享锁，那么另外的事务 T2 可以立即获得 r 行的共享锁，因为读取并没有改变 r 行的数据，称这种情况为锁兼容（Lock Compatible）。但若有其他的事务 T3 想获得 r 行的排他锁，则其必须等待事务 T1、T2 释放 r 行上的共享锁──这种情况称为锁不兼容。</p>
<p>下表显示了共享锁和排他锁的兼容性：</p>
<table>
<thead>
<tr>
<th></th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>兼容</td>
<td>冲突</td>
</tr>
<tr>
<td>X</td>
<td>冲突</td>
<td>冲突</td>
</tr>
</tbody></table>
<p>此外，InnoDB 存储引擎支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB 存储引擎支持一种额外的锁方式，称之为意向锁（Intention Lock）。意向锁是将锁定的对象分为多层次，意向锁意味着事务希望在更细粒度（fine granularity）上进行加锁。</p>
<p>若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。如下图，如果需要对页上的记录 r 进行 X 锁，那么首先需要对数据库 A、表、页上意向锁 IX，最后对记录 r 上 X 锁。若其中任何一个部分导致等待，那么该操作需要等待粗粒度锁的完成。比如说，在对记录 r 加 X 锁之前，已经有事务对该表进行了 S 表锁，那么表上已存在 S 锁，之后事务需要对记录 r 在表上加上 IX，由于不兼容，所以该事务需要等待表锁操作的完成。</p>
<p>InnoDB 存储引擎支持意向锁的设计比较简练，其意向锁即为表级别的锁。设计目的主要是为了在一个事务中揭示下一行将被请求的锁类型。其支持两种意向锁：</p>
<ol>
<li>意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁；</li>
<li>意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁。</li>
</ol>
<p>由于 InnoDB 存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫描以外的任何请求。下表展示了表级意向锁与行级锁的兼容性：</p>
<table>
<thead>
<tr>
<th></th>
<th>IS</th>
<th>IX</th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IS</strong></td>
<td>兼容</td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td><strong>IX</strong></td>
<td>兼容</td>
<td>兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>兼容</td>
<td>不兼容</td>
<td>兼容</td>
<td>不兼容</td>
</tr>
<tr>
<td><strong>X</strong></td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<p>在 InnoDB 1.0 版本之前，用户只能通过命令 <code>SHOW FULL PROCESSLIST</code>、<code>SHOW ENGINE INNODB STATUS</code> 等来查看当前数据库中锁的请求，然后再判断事务锁的情况。</p>
<p>从 InnoDB 1.0 开始，在 <code>INFORMATION_SCHEMA</code> 架构下添加了表 <code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>、<code>INNODB_LOCK_WAITS</code>。通过这三张表，用户可以更简单地监控当前事务并分析可能存在的锁问题。</p>
<p>下表是对于表 INNODB_TRX 的定义：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>trx_id</code></td>
<td>InnoDB 存储引擎内部唯一的事务 ID</td>
</tr>
<tr>
<td><code>trx_state</code></td>
<td>当前事务的状态</td>
</tr>
<tr>
<td><code>trx_started</code></td>
<td>事务的开始时间</td>
</tr>
<tr>
<td><code>trx_requested_lock_id</code></td>
<td>等待事务的锁 ID。如 <code>trx_state</code> 的状态为 <code>LOCK WAIT</code>，那么该值代表当前的事务等待之前事务占用锁资源的 ID。若 <code>trx_state</code> 不是 <code>LOCK WAIT</code>，则该值为 <code>NULL</code>。</td>
</tr>
<tr>
<td><code>trx_wait_started</code></td>
<td>事务等待开始的时间</td>
</tr>
<tr>
<td><code>trx_weight</code></td>
<td>事务的权重，反映了一个事务修改和锁住的行数。在 InnoDB 存储引擎中，当发生死锁需要回滚时，InnoDB 存储引擎会选择该值最小的进行回滚。</td>
</tr>
<tr>
<td><code>trx_mysql_thread_id</code></td>
<td>MySQL 中的线程 ID，<code>SHOW PROCESSLIST</code> 显示的结果</td>
</tr>
<tr>
<td><code>trx_query</code></td>
<td>事务运行的 SQL 语句</td>
</tr>
</tbody></table>
<p>下表是对于 INNODB_LOCKS 的定义：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>lock_id</code></td>
<td>锁的 ID</td>
</tr>
<tr>
<td><code>lock_trx_id</code></td>
<td>事务 ID</td>
</tr>
<tr>
<td><code>lock_mode</code></td>
<td>锁的模式</td>
</tr>
<tr>
<td><code>lock_type</code></td>
<td>锁的类型（表锁还是行锁）</td>
</tr>
<tr>
<td><code>lock_table</code></td>
<td>要加锁的表</td>
</tr>
<tr>
<td><code>lock_index</code></td>
<td>锁定的索引</td>
</tr>
<tr>
<td><code>lock_space</code></td>
<td>锁对象所在的 space id</td>
</tr>
<tr>
<td><code>lock_page</code></td>
<td>事务锁定页的数量；若是表锁，则该值为 <code>NULL</code></td>
</tr>
<tr>
<td><code>lock_rec</code></td>
<td>事务锁定行的数量；若是表锁，则该值为 <code>NULL</code></td>
</tr>
<tr>
<td><code>lock_data</code></td>
<td>事务锁定记录的主键值；若是表锁，则该值为 <code>NULL</code></td>
</tr>
</tbody></table>
<p>另外需要特别注意的是，在查看 <code>INNODB_LOCKS</code> 的内容时，<code>lock_data</code> 这个值并非是可信的值。例如当用户运行一个范围查找时， <code>lock_data</code> 可能只返回第一行的主键值。与此同时，如果当前资源被锁住了，若锁住的页因为 InnoDB 存储引擎缓冲池的容量，导致该页从缓冲池中被刷出，则在查看 <code>INNODB_LOCKS</code> 表时，该值同样会显示为 NULL，即 InnoDB 存储引擎不会从磁盘进行再一次的查找。</p>
<p>在通过表 <code>INNODB_LOCKS</code> 查看了每张表上锁的情况后，用户就可以来判断由此引发的等待情况了。当事务较小时，用户就可以人为地、直观地进行判断。但是当事务量非常大，其中锁和等待也时常发生，这个时候就不会这么容易判断。但是通过表 <code>INNODB_LOCK_WAITS</code> ，可以很直观地反映当前事务的等待。表 <code>INNODB_LOCK_WAITS</code> 的结构如下表。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>requesting_trx_id</code></td>
<td>申请锁资源的事务 ID</td>
<td><code>blocking_trx_id</code></td>
<td>阻塞的事务 ID</td>
</tr>
<tr>
<td><code>requesting_lock_id</code></td>
<td>申请的锁的 ID</td>
<td><code>blocking_lock_id</code></td>
<td>阻塞的锁的 ID</td>
</tr>
</tbody></table>
<p>总的来说，用户可以结合 <code>INNODB_TRX</code>、<code>INNODB_LOCKS</code>、<code>INNODB_LOCK_WAITS</code> 三张表进一步查询。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  r.trx_id      <span class="keyword">AS</span> waiting_trx_id,</span><br><span class="line">  r.trx_mysql_thread_id <span class="keyword">AS</span> waiting_thread,</span><br><span class="line">  r.trx_query     <span class="keyword">AS</span> waiting_query,</span><br><span class="line">  b.trx_id      <span class="keyword">AS</span> blocking_trx_id,</span><br><span class="line">  b.trx_mysql_thread_id <span class="keyword">AS</span> blocking_thread,</span><br><span class="line">  b.trx_query     <span class="keyword">AS</span> blocking_query</span><br><span class="line"><span class="keyword">FROM</span> information_schema.innodb_lock_waits w</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx b</span><br><span class="line">  <span class="keyword">ON</span> b.trx_id <span class="operator">=</span> w.blocking_trx_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> information_schema.innodb_trx r</span><br><span class="line">  <span class="keyword">ON</span> r.trx_id <span class="operator">=</span> w.requesting_trx_id\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">waiting_trx_id:    <span class="number">73122</span>F</span><br><span class="line">waiting_thread:    <span class="number">471719</span></span><br><span class="line">waiting_query:    <span class="keyword">NULL</span></span><br><span class="line">blocking_trx_id:   <span class="number">7311</span>FC</span><br><span class="line">blocking_thread:   <span class="number">471718</span></span><br><span class="line">blocking_query:    <span class="keyword">NULL</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><strong>按照锁的粒度可分为：</strong></p>
<p><strong>全局锁</strong>：对整个数据库实例加锁，实例处于只读状态。</p>
<p>使用场景：进行整个数据库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据完整性（DDL，DML 语句被阻塞，DQL 正常运行）。</p>
<p>步骤：</p>
<ol>
<li>加锁：<code>flush tables with read lock;</code></li>
<li>数据备份：<code>mysqldump -h192.168.200.202 -uroot -p1234 db01 &gt; db01.sql</code></li>
<li>解锁：<code>unlock tables;</code></li>
</ol>
<p>产生的问题：</p>
<p>如果在主库上备份，备份期间不能执行插入、更新等操作，<strong>业务基本上停摆</strong>。</p>
<p>如果在从库上备份，备份期间从库不能执行主库同步过来的二进制日志，导致<strong>主从延迟</strong>。</p>
<p>解决方法：</p>
<p>备份时，加上参数 -single-transaction 来完成不加锁的一致性数据备份（快照读取）：<code>mysqldump -single-transaction -h192.168.200.202 -uroot -p1234 db01 &gt; db01.sql</code></p>
<p><strong>表级锁</strong>：开销小，加锁快；锁定力度大，发生锁冲突概率高，并发度最低；不会出现死锁。</p>
<p>表**共享-**读锁：当表被 READ 锁定时，其他会话只能获取该表的 READ 锁，不能获取 WRITE 锁。READ 锁的会话可以进行读取操作（SELECT），但不能进行写入操作（INSERT、UPDATE、DELETE 等）。同时，加了 READ 锁的会话可以与其他 READ 锁并发读取表数据，但不能有写入操作。</p>
<p>表**独占-**写锁：当表被 WRITE 锁定时，其他所有会话都不能对该表进行任何操作（无论是读还是写），只有当前会话可以进行读写操作。写锁是独占锁，一旦被某个会话持有，其他会话都必须等待该锁被释放。</p>
<p>使用语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock tables table_name1, table_name2 read<span class="operator">/</span>write;</span><br><span class="line">unlock tables <span class="operator">/</span> 客户端断开连接;</span><br></pre></td></tr></table></figure>

<p>当客户端与 MySQL 服务器断开连接时，MySQL 会自动释放当前会话持有的所有表锁。这是为了防止锁永远保持不释放的情况，因为锁定表的会话已经断开，不再能主动解锁。</p>
<p><strong>元数据锁（meta data lock，MDL）</strong></p>
<p>元数据是控制表结构、表逻辑相关的信息。加锁过程由系统自动控制，无需显式使用。</p>
<p>当我们执行诸如 CREATE TABLE、DROP TABLE、ALTER TABLE 等 DDL（数据定义语言）语句时，MySQL 需要对表的元数据进行修改。在这些情况下，MDL 锁可以防止其他事务同时进行操作，确保结构修改的安全性。</p>
<p>当我们执行 SELECT、INSERT、UPDATE、DELETE 等 DML（数据操作语言）语句时，MySQL 也会申请 MDL 锁以保护表结构，防止在读取或写入数据的过程中表结构发生改变。</p>
<p>MDL 锁的类型：</p>
<p>MDL 共享锁（MDL Shared Lock）：</p>
<ul>
<li>当事务对表进行读取（如 SELECT）或普通的数据操作（如 INSERT、UPDATE）时，会申请 MDL 共享锁。</li>
<li>共享锁之间是兼容的，即多个事务可以同时持有 MDL 共享锁，这样可以允许多个事务同时读写表中的数据。</li>
</ul>
<p>MDL 排他锁（MDL Exclusive Lock）：</p>
<ul>
<li>当事务要对表进行结构修改（如 ALTER TABLE）时，会申请 MDL 排他锁。</li>
<li>MDL 排他锁与其他所有类型的锁都不兼容。因此，在表结构被修改期间，其他事务将被阻塞，直到持有排他锁的事务提交或回滚。</li>
</ul>
<p>查看 MDL：<code>select * from performance_schema.metadata_locks;</code></p>
<table>
<thead>
<tr>
<th>SQL 语句</th>
<th>锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>lock tables xxx read &#x2F; write</td>
<td>shared_read_only &#x2F; shared_no_read_write</td>
<td></td>
</tr>
<tr>
<td>select, select … lock in share mode</td>
<td>shared_read</td>
<td>与 shared_read, shared_write 兼容，与 exclusive 互斥</td>
</tr>
<tr>
<td>insert, update, delete, select … for update</td>
<td>shared_write</td>
<td>与 shared_read, shared_write 兼容，与 exclusive 互斥</td>
</tr>
<tr>
<td>alter table …</td>
<td>exclusive</td>
<td>与其他 MDL 都互斥</td>
</tr>
</tbody></table>
<p><strong>意向锁</strong></p>
<p>意向锁的出现是为了支持 InnoDB 的多粒度锁，它的主要作用是用来<strong>协调表级锁和行级锁之间的关系</strong>，从而提升锁定机制的性能和效率。它的核心用途是为了在表级别加锁时能够快速判断是否存在冲突，防止误加表级锁而导致锁冲突或死锁。</p>
<p><strong>意向锁本质</strong>：只是用于标识即将进行的锁操作。它主要用于快速判断是否可以对表或表中某些行施加其他类型的锁。</p>
<p>我们需要加表锁时，需要判断表中有没有数据行被锁定，以确定是否能加锁成功。</p>
<p>之前没有意向锁，我们就得遍历表中所有数据行来判断有没有行锁；有了意向锁这个表级锁之后，我们直接判断意向锁是否存在便可知表中是否有数据行被锁定。</p>
<p>有了意向锁之后，要执行的事务 A 在申请行锁（写锁）之前，数据库会自动先给事务 A 申请表的<strong>意向排他锁</strong>。当事务 B 去申请表的互斥锁时就会失败，因为表上有意向排他锁之后事务 B 申请表的互斥锁时会被阻塞。</p>
<ol>
<li>意向共享锁（IS）：由语句 <code>select ... lock in share mode;</code> 添加。</li>
</ol>
<ul>
<li>当一个事务打算对表中的某些行加共享锁（S 锁）时，它会在表级别加一个意向共享锁（IS 锁）。</li>
<li>意向共享锁之间是兼容的，可以允许多个事务同时对表中不同的行加共享锁。</li>
</ul>
<ol>
<li>意向排他锁（IX）：由 insert，update，delete，<code>select … for update;</code> 添加。</li>
</ol>
<ul>
<li>当一个事务打算对表中的某些行加排他锁（X 锁）时，它会在表级别加一个意向排他锁（IX 锁）。</li>
<li>意向排他锁之间也是兼容的，允许多个事务同时对表中不同的行加排他锁或共享锁。</li>
</ul>
<p>查看：<code>select * from performace_schema.data_locks;</code></p>
<p>下表中的 S 和 X 指的是表级锁，<strong>意向锁不会与行级的读写锁互斥！！！</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>X 锁</th>
<th>S 锁</th>
</tr>
</thead>
<tbody><tr>
<td><strong>IS 锁</strong></td>
<td>不兼容</td>
<td>兼容</td>
</tr>
<tr>
<td><strong>IX 锁</strong></td>
<td>不兼容</td>
<td>不兼容</td>
</tr>
</tbody></table>
<p>意向锁的使用场景</p>
<ol>
<li>行级锁与表级锁的兼容性检测：<ul>
<li>当一个事务需要对表中的某些行加锁时，它会先在表级别加上相应的意向锁（IS 或 IX）。</li>
<li>这样，当其他事务尝试获取表级锁（例如 <code>LOCK TABLES</code>）时，只需要检查表级别的意向锁状态，就可以知道是否可以安全地进行加锁操作。</li>
</ul>
</li>
<li>防止死锁：<ul>
<li>通过使用意向锁，可以有效防止死锁的发生。例如，如果两个事务同时尝试对表的不同部分加锁，如果没有意向锁的机制，可能会导致相互等待，最终陷入死锁。</li>
<li>意向锁通过明确锁的意图，可以提前检测到潜在的冲突，从而避免死锁情况的出现。</li>
</ul>
</li>
</ol>
<p><strong>行级锁</strong>：开销大，加锁慢；锁定粒度小，发生锁冲突概率低，并发度高；会出现死锁。通过对索引中叶子节点的索引项加锁来实现。</p>
<p>行级锁的具体实现包含：记录锁，间隙锁和邻键锁。</p>
<p>记录锁（record lock）：锁定单个行的锁，防止其它事务对此进行 update 和 delete，在 Read committed、Repeatable read 隔离级别下都支持。</p>
<p><img src="/../../images/MySQL/mysql_locking_rec.drawio.png" alt="img"></p>
<ul>
<li>共享锁（S）：允许一个事务读一行，阻止其它事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获取排他锁的事务更新数据，阻止其它事务获得相同数据集的共享锁和排他锁。</li>
</ul>
<table>
<thead>
<tr>
<th>SQL</th>
<th>行锁类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>insert</td>
<td>X</td>
<td>自动加锁</td>
</tr>
<tr>
<td>update</td>
<td>X</td>
<td>自动加锁</td>
</tr>
<tr>
<td>delete</td>
<td>X</td>
<td>自动加锁</td>
</tr>
<tr>
<td>select （正常）</td>
<td>不加任何锁</td>
<td></td>
</tr>
<tr>
<td>select … lock in share mode</td>
<td>S</td>
<td>需要手动在select之后加lock in share mode</td>
</tr>
<tr>
<td>select … for update</td>
<td>X</td>
<td>需要手动在select之后添加for update</td>
</tr>
</tbody></table>
<p>间隙锁（gap lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其它事务在这个间隙进行插入操作以产生幻读，在 Repeatable read 隔离级别下支持。间隙锁可共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p>
<p><img src="/../../images/MySQL/mysql_locking_gap.drawio.png" alt="img"></p>
<p>以 <code>SELECT * FROM employees WHERE age BETWEEN 25 AND 30 FOR UPDATE;</code> 为例：</p>
<p>InnoDB 会对二级索引 age 的叶子节点加锁，包括：</p>
<ul>
<li>范围内存在的所有索引项（记录锁）。</li>
<li>范围内不存在记录的“间隙”部分（间隙锁）。</li>
</ul>
<p>随后，对这些索引项所指向的聚簇索引中的行数据加锁。</p>
<p>也就是说这种情况下，二级索引和聚簇索引的多个节点都会被加锁，以避免幻读和保证一致性。</p>
<p>除了上述例子的一致性锁定读之外，UPDATE 和 DELETE 在查询非唯一索引时也会使用间隙锁。</p>
<p>间隙锁可能带来的问题</p>
<ol>
<li>降低并发性能：间隙锁锁住的是一个范围，而不是具体的行，因此可能导致较多事务被阻塞。例如，一个简单的范围查询可能锁住比预期更多的行或区间。</li>
<li>死锁风险增加：由于间隙锁锁定的范围较广，在高并发场景下，多个事务可能会竞争相邻的间隙，导致死锁。</li>
<li>仅适用于索引字段：间隙锁只能作用于有索引的字段。如果字段没有索引，在 InnoDB 下会退化为表锁，从而进一步降低性能。</li>
</ol>
<p>临键锁（next-key lock）：行锁和间隙锁的组合，同时锁住数据以及数据前面的间隙（左开右闭区间），在 Repeatable read 隔离级别下支持。该锁用于解决幻读问题。</p>
<p><img src="/../../images/MySQL/mysql_locking_nxt_key.drawio.png" alt="img"></p>
<p>当查询的索引是针对唯一属性列时，临键锁会退化为记录锁，因为没必要锁一个区间，所有该字段的值都是唯一值。</p>
<p>此外，对于非唯一索引，如果查询的数据存在，那么 InnoDB 还会对该索引中的下一个区间加间隙锁。</p>
<p>假设我们创建一个表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> z ( a <span class="type">INT</span>, b <span class="type">INT</span>, <span class="keyword">PRIMARY KEY</span>(a), KEY(b) );</span><br></pre></td></tr></table></figure>

<p>表 z 的列 b 是辅助索引，若在会话 A 中执行下面的 SQL 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">3</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">5</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">7</span>,<span class="number">6</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">10</span>,<span class="number">8</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> z <span class="keyword">WHERE</span> b<span class="operator">=</span><span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<p>很明显，这时 SQL 语句通过索引列 b 进行查询，因此其使用传统的 Next-Key Locking 技术加锁，并且由于有两个索引，其需要分别进行锁定。对于聚集索引，其仅对列 a 等于 5 的索引加上 Record Lock。而对于辅助索引，其加上的是 Next-Key Lock，锁定的范围是 <code>(1, 3)</code>，特别需要注意的是，InnoDB 存储引擎还会对辅助索引下一个键值</p>
<p>加上 gap lock，即还有一个辅助索引范围为 <code>(3, 6)</code> 的锁。因此，若在新会话 B 中执行下面的 SQL 语句，都会被阻塞：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> z <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">5</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">4</span>,<span class="number">2</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>第一个 SQL 语句不能执行，因为在会话 A 中执行的 SQL 语句已经对聚集索引中列 a &#x3D; 5 的值加上 X 锁，因此执行会被阻塞。第二个 SQL 语句，主键插入 4，没有问题，但是插入的辅助索引值 2 在锁定的范围 <code>(1, 3)</code> 中，因此执行同样会被阻塞。第三个 SQL 语句，插入的主键 6 没有被锁定，5 也不在范围 <code>(1, 3)</code> 之间。但插入的值 5 在另一个锁定的范围 <code>(3, 6)</code> 中，故同样需要等待。而下面的 SQL 语句，不会被阻塞，可以立即执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">8</span>,<span class="number">6</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">2</span>,<span class="number">0</span>;</span><br><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<p>从上面的例子中可以看到，Gap Lock 的作用是为了阻止多个事务将记录插入到同一范围内，而这会导致 Phantom Problem 问题的产生。例如在上面的例子中，会话 A 中用户已经锁定了 b &#x3D; 3 的记录。若此时没有 Gap Lock 锁定 <code>(3, 6)</code>，那么用户可以插入索引 b 列为 3 的记录，这会导致会话 A 中的用户再次执行同样查询时会返回不同的记录，即导致 Phantom Problem 问题的产生。</p>
<p>用户可以通过以下两种方式来显式地关闭 Gap Lock：</p>
<ul>
<li>将事务的隔离级别设置为 READ COMMITTED</li>
<li>将参数 <code>innodb_locks_unsafe_for_binlog</code> 设置为 1</li>
</ul>
<p>在上述的配置下，除了外键约束和唯一性检查依然需要的 Gap Lock，其余情况仅使用 Record Lock 进行锁定。但需要牢记的是，上述设置破坏了事务的隔离性，并且对于 replication，可能会导致主从数据的不一致。此外，从性能上来看，READ COMMITTED 也不会优于默认的事务隔离级别 READ REPEATABLE。</p>
<p>在 InnoDB 存储引擎中，对于 INSERT 的操作，其会检查插入记录的下一条记录是否被锁定，若已经被锁定，则不允许查询。对于上面的例子，会话 A 已经锁定了表 z 中 b &#x3D; 3 的记录，即已经锁定了 <code>(1, 3)</code> 的范围，这时若在其他会话中进行如下的插入同样会导致阻塞：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">2</span>,<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>因为在辅助索引列 b 上插入值为 2 的记录时，会监测到下一个记录 3 已经被索引。而将插入修改为如下的值，可以立即执行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">2</span>,<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，对于唯一键值的锁定，Next-Key Lock 降级为 Record Lock 仅存在于查询所有的唯一索引列。若唯一索引由多个列组成，而查询仅是查找多个唯一索引列中的其中一个，那么查询其实是 range 类型查询，而不是 point 类型查询，故 InnoDB 存储引擎依然使用 Next-Key Lock 进行锁定。</p>
<p>InnoDB 存储引擎默认的事务隔离级别是 REPEATABLE READ，在该隔离级别下，其采用 Next-Key Locking 的方式来加锁。而在事务隔离级别 READ COMMITTED 下，其仅采用 Record Lock。</p>
<p>此外，用户可以通过 InnoDB 存储引擎的 Next-Key Locking 机制在应用层面实现唯一性的检查。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> col <span class="operator">=</span> xxx LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"></span><br><span class="line">If <span class="keyword">not</span> found <span class="keyword">any</span> <span class="type">row</span>:</span><br><span class="line">  # <span class="keyword">unique</span> <span class="keyword">for</span> <span class="keyword">insert</span> <span class="keyword">value</span></span><br><span class="line">  <span class="keyword">INSERT INTO</span> <span class="keyword">table</span> <span class="keyword">VALUES</span> (...);</span><br></pre></td></tr></table></figure>

<p>如果用户通过索引查询一个值，并对该值加上一个 SLock，那么即使查询的值不存在，其锁定的也是一个范围。因此若没有返回任何行，那么新插入的值一定是唯一的。或许有读者会疑问：如果在进行第一步 <code>SELECT … LOCK IN SHARE MODE</code> 操作时，有多个事务并发操作，那么这种唯一性检查机制是否存在问题？其实并不会，因为这时会导致死锁，只有一个事务的插入操作会成功，而其余的事务会抛出死锁错误。如下表所示：</p>
<table>
<thead>
<tr>
<th><strong>时间</strong></th>
<th><strong>会话 A</strong></th>
<th><strong>会话 B</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>SELECT * FROM z WHERE b&#x3D;4 LOCK IN SHARE MODE;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>SELECT * FROM z WHERE b&#x3D;4 LOCK IN SHARE MODE;</td>
</tr>
<tr>
<td>4</td>
<td>INSERT INTO z SELECT 4,4; # 阻塞</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>INSERT INTO z SELECT 4,4; ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction # 抛出死锁异常，并打破死锁</td>
</tr>
<tr>
<td>6</td>
<td># INSERT 插入成功</td>
<td></td>
</tr>
</tbody></table>
<p><strong>插入意向锁</strong></p>
<p>插入意向锁是间隙粒度的锁，精细到单个索引页里某两个值之间的区间，用于标识事务计划在某个索引间隙内插入数据而加设的锁。它并不锁定具体已存在的行，而是将要插入的位置所在的间隙临时锁定为计划插入，从而允许多个事务在同一间隙内并发插入不同的记录。也就是说，插入意向锁仅表示意向，不直接阻塞其他事务对同一间隙的插入，只要插入位置互不冲突即可并发执行。 </p>
<p>它介于行级（Record Lock，锁已存在行）和页&#x2F;表级（锁整页或整表）之间，用来协调多个事务同时往同一个区间插入新行，而不去阻塞彼此。该锁的设计初衷是<strong>提高并发插入能力</strong>，减少因行锁或表级锁而产生的阻塞。</p>
<p>当执行 INSERT 语句时，InnoDB 会先定位插入值在聚集索引（或唯一索引）中的正确位置。在真正写入新行之前，InnoDB 会对该插入间隙加上插入意向锁，以表明本事务计划在此间隙插入数据。只有当此时该间隙已经被其他事务以 Gap Lock 形式范围锁定（如执行范围扫描加锁）时，才能导致当前插入意向锁请求被阻塞。否则，插入意向锁之间互不冲突。</p>
<p>获得插入意向锁后，InnoDB 会继续在实际要插入的新行位置加行级写锁，确保后续写操作的原子性与一致性。在插入完成并提交后，这条新插入行上的行锁保持至事务结束，然后随着事务提交释放；插入意向锁在加行锁后也会被释放，不会持续阻塞。</p>
<p>任何普通的 INSERT 操作（包括单行插入和多行插入），在执行前都会对目标插入点所在的索引空隙加一个插入意向锁，表明当前事务打算在此处插入新行，但不会阻塞同一区间的其他插入操作。</p>
<p>InnoDB 在 REPEATABLE READ 隔离级别下，针对不同类型的索引检索与扫描操作采取了不同的锁策略：</p>
<ul>
<li>执行的范围扫描（如 <code>SELECT … FOR UPDATE</code>、UPDATE、DELETE 等）会使用 Next-Key 锁，它相当于给索引记录加上行锁（Record Lock），同时对该记录之前的空隙加上间隙锁，从而禁止并发事务在此间隙插入幻行。</li>
<li>当对唯一索引进行等值查询（unique index + … WHERE key &#x3D; value）时，如果能精确匹配到某条已存在记录，InnoDB 会直接对该记录加行级锁（Record Lock），而不再对前置间隙加锁（即不使用 Gap Lock）。这种唯一索引 + 等值匹配的情况被 InnoDB 自动优化为仅行锁，以减少锁级别和冲突。</li>
<li>InnoDB 的行锁是加在索引记录上的，如果某条查询完全不经过索引（例如全表扫描、非索引列条件），InnoDB 会退化为给整张表加表级锁。</li>
<li>当在 唯一索引上执行等值查询，但该值在表中不存在（即要锁定某个不存在的记录）时，InnoDB 会对对应索引位置的空隙加上间隙锁，防止其他事务在该位置插入新行。</li>
<li>在非唯一索引上执行等值查询（ordinary index + WHERE key &#x3D; value）时，InnoDB 会先沿索引向右遍历查找匹配行；若查到的最后一个值仍不满足等值条件，Next-Key 锁会退化为仅加间隙锁，而不是继续对某条不存在的记录加行锁。</li>
<li>在唯一索引上执行范围查询（<code>WHERE key BETWEEN a AND b</code> 或 <code>WHERE key &gt; a</code> 等），InnoDB 访问到第一个不满足条件的值后就停止，这也保证了越界位置的间隙锁效果——只锁定真正满足条件的记录之前的空隙，避免后续出现新的幻行。</li>
</ul>
<p>按照加锁机制可分为：</p>
<p><strong>乐观锁</strong></p>
<p>乐观锁假设冲突在系统中出现的频率较低，因此在数据库事务执行过程中，不会频繁地去锁定资源。相反，它在提交更新的时候才检查是否有其他事务已经修改了数据。</p>
<p>可以通过在数据表中使用版本号或时间戳来实现，每次读取记录时，同时获取版本号或时间戳，更新时检查版本号或时间戳是否发生变化。</p>
<p>如果没有变化，则执行更新并增加版本号或更新时间戳；如果检测到冲突（即版本号或时间戳与之前读取的不同），则拒绝更新。</p>
<p><strong>悲观锁</strong></p>
<p>悲观锁假设冲突是常见的，因此在数据处理过程中，它会主动锁定数据，防止其他事务进行修改。</p>
<p>可以直接使用数据库的锁机制，如行锁或表锁，来锁定被访问的数据。常见的实现是 <code>SELECT FOR UPDATE</code> 语句，它在读取数据时就加上了锁，直到当前事务提交或回滚后才释放。</p>
<p><strong>解决库存超买问题</strong></p>
<p>乐观锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> inventory <span class="keyword">SET</span> count <span class="operator">=</span> count <span class="operator">-</span> <span class="number">1</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> <span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">AND</span> version <span class="operator">=</span> current_version;</span><br></pre></td></tr></table></figure>

<p>因此乐观锁通过不断递增的版本号来控制并发事务。</p>
<p>悲观锁</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> inventory <span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> inventory <span class="keyword">SET</span> count <span class="operator">=</span> count <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>由此可见，悲观锁会在事务开始时直接锁定库存记录，直到事务结束。</p>
<h3 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h3><p>一致性非锁定读是一种利用多版本并发控制（MVCC）的读取方式。当事务执行普通的 SELECT 语句时，即使另一事务正在对同一行进行 UPDATE 或 DELETE，读取操作也不会被阻塞。</p>
<p>InnoDB 会为每条记录在 undo 段中保存历史版本。当读取请求到来时，若目标行正被加锁或已被修改，InnoDB 会取用该行的快照数据（历史版本）而非等待当前锁的释放，从而实现非锁定地读取一致性数据。</p>
<p>每次对行执行更新或删除时，InnoDB 会将修改前的行数据写入 undo 段，形成一个快照版本。一个行记录可能拥有多个历史版本，每个版本对应不同时间点的值。通过在事务启动时或者读取时确定一个合适的版本，InnoDB 能保证读取到符合隔离级别要求的“旧数据”或“最新已提交数据”，而不去抢占当前正在被写锁定的行。</p>
<p>由于读取操作无需等待行级锁释放，InnoDB 的并发性能大幅提升。读操作不会阻塞写操作，写操作也不会过度影响其它读事务。</p>
<p>在大多数情况下，事务仅需访问行快照，即可保证数据一致性，无须引入额外锁，从而避免死锁与锁等待带来的性能开销。</p>
<p>**READ COMMITTED：**每次读取都会取当前最新的“已提交”快照。若在同一事务中连续执行两次相同查询，第二次查询可能看到其他事务已提交的更新。</p>
<p>**REPEATABLE READ（InnoDB 默认）：**事务启动后即确定一个读取视图（snapshot），所有后续读取都基于该视图中的版本。无论其他事务如何提交，当前事务看到的行数据都是事务开始时的一致快照。</p>
<h3 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h3><p>在 InnoDB 默认的 REPEATABLE READ 隔离级别下，普通的 SELECT 都是非锁定的一致性读，通过 MVCC 机制读取快照而不会阻塞或等待行锁。但在某些业务场景中，用户需要显式地对读取到的数据加锁，以强制保证数据逻辑上的一致性，此时就需要使用“一致性锁定读”。</p>
<p>InnoDB 支持对 SELECT 语句加锁的两种方式：</p>
<ul>
<li><code>SELECT … FOR UPDATE</code></li>
<li><code>SELECT … LOCK IN SHARE MODE</code></li>
</ul>
<p>其中：</p>
<ul>
<li><code>SELECT … FOR UPDATE</code><ul>
<li>会对检索到的每一行记录加上排他锁。</li>
<li>一旦某行被 X 锁锁定，其他事务既不能对该行加 X 锁，也不能加 S 锁，必须等该事务提交或回滚后才可访问。</li>
</ul>
</li>
<li><code>SELECT … LOCK IN SHARE MODE</code><ul>
<li>会对检索到的每一行记录加上共享锁。</li>
<li>其他事务可以对该行继续加共享锁（并发读取），但若尝试加排他锁就会被阻塞，直到 S 锁释放。</li>
</ul>
</li>
</ul>
<p><code>SELECT … FOR UPDATE</code>&#x2F;<code>LOCK IN SHARE MODE</code> 必须在显式事务内执行，也就是在执行之前要先执行：</p>
<ul>
<li><code>BEGIN</code> 或 <code>START TRANSACTION</code></li>
<li>或者将会话设置为 <code>SET AUTOCOMMIT=0</code>，然后执行 <code>SELECT … FOR UPDATE</code>／<code>SELECT … LOCK IN SHARE MODE</code>。</li>
</ul>
<p>只有在事务结束后（提交或回滚），这些行锁才会被释放，其他事务才能继续操作这些行。</p>
<p>对于一致性非锁定读，就算目标行正在被 X 锁锁定，InnoDB 依然能通过读取行的历史快照来返回结果，不会阻塞。</p>
<h3 id="自增长与锁"><a href="#自增长与锁" class="headerlink" title="自增长与锁"></a>自增长与锁</h3><p>自增长在数据库中是非常常见的一种属性。在 InnoDB 存储引擎的内存结构中，每个含有自增长值的表都有一个自增长计数器（auto-increment counter）。当对含有自增长计数器的表进行插入操作时，这个计数器会被初始化，执行如下语句来得到计数器的值：</p>
<p>插入操作会依据这个自增长计数器的值加 1 赋予自增列。这个实现方式称做 AUTO-INC Locking。这种锁其实是采用一种特殊的表锁机制，为了提高插入的性能，锁不是在一个事务完成后才释放，而是在完成对自增长值插入的 SQL 语句后立即释放。</p>
<p>虽然 AUTO-INC Locking 从一定程度上提高了并发插入的效率，但还是存在一些性能上的问题。首先，对于有自增长值的列的并发插入性能较差，事务必须等待前一个插入的完成（虽然不用等待整个事务的结束）。其次，对于 <code>INSERT … SELECT</code> 的大数据量插入，会影响插入的性能，因为此时另一个事务中的插入会被阻塞。</p>
<p>从 MySQL 5.1.22 版本开始，InnoDB 存储引擎中提供了一种轻量级互斥量的自增长实现机制，这种机制大大提高了自增长值插入的性能。并且从该版本开始，InnoDB 存储引擎提供了一个参数 <code>innodb_autoinc_lock_mode</code> 来控制自增长的模式，该参数的默认值为 1。</p>
<p>下表对插入操作进行分类：</p>
<table>
<thead>
<tr>
<th>插入类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>insert-like</code></td>
<td>insert-like 指所有的插入语句，如 <code>INSERT</code>、<code>REPLACE</code>、<code>INSERT … SELECT</code>、<code>REPLACE … SELECT</code>、<code>LOAD DATA</code> 等</td>
</tr>
<tr>
<td><code>simple inserts</code></td>
<td>simple inserts 指能在插入前就确定插入行数的语句。这些语句包括 <code>INSERT</code>、<code>REPLACE</code> 等。需要注意的是：simple inserts 不包含 <code>INSERT … ON DUPLICATE KEY UPDATE</code> 这类 SQL 语句</td>
</tr>
<tr>
<td><code>bulk inserts</code></td>
<td>bulk inserts 指在插入前不能确定插入行数的语句，如 <code>INSERT … SELECT</code>、<code>REPLACE … SELECT</code>、<code>LOAD DATA</code></td>
</tr>
<tr>
<td><code>mixed-mode inserts</code></td>
<td>mixed-mode inserts 指插入中有一部分的值是自增的，有一部分是确定的。如：<br><code>INSERT INTO t1 (c1,c2) VALUES (1,&#39;a&#39;), (NULL,&#39;b&#39;), (5,&#39;c&#39;), (NULL,&#39;d&#39;);</code><br>也可以指 <code>INSERT … ON DUPLICATE KEY UPDATE</code> 这类 SQL 语句</td>
</tr>
</tbody></table>
<p><code>innodb_autoinc_lock_mode</code> 有三个有效值可供设定，具体如下：</p>
<table>
<thead>
<tr>
<th>innodb_autoinc_lock_mode</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>这是 MySQL 5.1.22 版本之前自增长的实现方式，即通过表锁的 AUTO-INC Locking 方式。因为有了新的自增长实现方式，0 这个选项不应该是新版用户的首选项。</td>
</tr>
<tr>
<td>1</td>
<td>这是该参数的默认值。• 对于 “simple inserts” （简单插入），该值会用互斥量（mutex）去对内存中的计数器进行累加操作。• 对于 “bulk inserts” （批量插入），还是使用传统锁的 AUTO-INC Locking 方式。在这种配置下，如果不考虑回滚操作，对于自增值的增长还是连续的。并且在这种方式下，statement-based 方式的 replication 还是能很好地工作。• 需要注意的是，如果已经使用 AUTO-INC Locking 方式产生自增长值，而这时需要再进行 “simple inserts” 的操作时，还是需要等待 AUTO-INC Locking 的释放。</td>
</tr>
<tr>
<td>2</td>
<td>在这个模式下，对于所有 “insert-like” 自增长值的产生都是通过互斥量，而不是 AUTO-INC Locking 的方式。显然，这会带来一定的问题，因为并发插入的存在，在每次插入时，自增值的值不保证是连续的。此外，最重要的是，基于 Statement-Based Replication 会出现问题。因此，使用该模式，任何时候都应该使用 row-based replication。这样才能保证最大的并发性能及 replication 主从数据的一致。</td>
</tr>
</tbody></table>
<p>此外，还需要特别注意的是，在 InnoDB 存储引擎中自增长的实现和 MyISAM 不同。MyISAM 存储引擎是表锁设计，自增长不考虑并发插入的问题。因此在 master 上用 InnoDB 存储引擎，在 slave 上用 MyISAM 存储引擎的 replication 架构下，用户必须考虑这种情况。</p>
<p>上表中，并发插入问题指的是在高并发场景下，用互斥量（mutex）保护自增计数器时会出现的两类问题：</p>
<ol>
<li>ID 分配成为串行瓶颈<ul>
<li>互斥量会让每个插入请求都要轮流抢一次锁，才能执行 <code>counter++</code> 并分配一个自增值。这在并发插入很高时，会频繁争抢同一个互斥量，造成吞吐下降。</li>
</ul>
</li>
<li>自增 ID 不连续或乱序<ul>
<li>互斥量模式下，插入时就分配 ID。如果某个事务分配到 ID 后回滚，这个号就空了，导致跳号更明显。</li>
<li>并发事务各自抢到互斥量分配 ID，但可能是后抢到的人先真正写入、先提交，最终物理插入顺序与 ID 逻辑顺序并不一致。</li>
</ul>
</li>
</ol>
<p>在 InnoDB 存储引擎中，如果要让某个列使用 <code>AUTO_INCREMENT</code> 功能，必须满足两个条件：</p>
<ol>
<li>该列要有索引；</li>
<li>在对应索引中，它必须是最左边（第一列）。</li>
</ol>
<p>如果把自增列放在联合索引但不是第一个字段，或者根本没给它建立索引，InnoDB 会报错并拒绝插入；而 MyISAM 在相同情况下则不会报异常。</p>
<h3 id="外键和锁"><a href="#外键和锁" class="headerlink" title="外键和锁"></a>外键和锁</h3><p>InnoDB 在创建外键时，如果外键列上没有显式索引，会自动为该列创建一个索引，以避免全表扫描带来的锁争用。<br>当对子表执行插入或更新外键列（即要引用父表某条记录）时，InnoDB 必须先查询父表确保对应的主键（或唯一键）存在。</p>
<p>但简单的 一致性非锁定读（普通 SELECT）并不能保证在事务并发环境中数据的一致性——可能会出现脏写或幻读情形。</p>
<p>因此，InnoDB 在查询父表时会使用 <code>SELECT … LOCK IN SHARE MODE</code>，对父表所查的行加一个 S 锁（共享锁）。这样做有两个作用：</p>
<ol>
<li>防止父表被并发事务删除或更新：如果父表对应行已被其他事务加了 X 锁（排他锁），子事务在 <code>LOCK IN SHARE MODE</code> 时就会阻塞，直到父锁释放为止。</li>
<li>保证外键引用时数据不会不一致：只有拿到父表的 S 锁，才能证明此父键在本事务内是稳固存在的、不被其他事务删除或修改。</li>
</ol>
<p>如果此时父表相应行已经被别的事务用 <code>SELECT … FOR UPDATE</code> 或 UPDATE&#x2F;DELETE 加上了 X 锁，子表的外键检查就必须等这一 X 锁释放后才能继续。</p>
<p>也就是说，外键引用操作会被刻意设计成主动等待父表可读且稳固的状态，从而避免插入不存在的父记录或引用已改&#x2F;已删的数据。</p>
<h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它所占用的资源，这就是阻塞。阻塞并不是一件坏事，其是为了确保事务可以并发且正常地运行。</p>
<p>在 InnoDB 存储引擎中，参数 <code>innodb_lock_wait_timeout</code> 用来控制等待的时间（默认是 50 秒），<code>innodb_rollback_on_timeout</code> 用来设定是否在等待超时时对进行中的事务进行回滚操作（默认为 OFF，代表不回滚）。参数 <code>innodb_lock_wait_timeout</code> 是动态的，可以在 MySQL 数据库运行时进行调整：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> @<span class="variable">@innodb_lock_wait_timeout</span><span class="operator">=</span><span class="number">60</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>而 <code>innodb_rollback_on_timeout</code> 是静态的，不可在启动时进行修改，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> @<span class="variable">@innodb_rollback_on_timeout</span><span class="operator">=</span><span class="keyword">on</span>;</span><br><span class="line">ERROR <span class="number">1238</span> (HY000): Variable <span class="string">&#x27;innodb_rollback_on_timeout&#x27;</span> <span class="keyword">is</span> a read <span class="keyword">only</span> variable</span><br></pre></td></tr></table></figure>

<p>当发生超时，MySQL 数据库会抛出一个 1205 的错误，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">BEGIN</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t <span class="keyword">WHERE</span> a <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">ERROR <span class="number">1205</span> (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在默认情况下 InnoDB 不会回滚超时引发的错误异常，其实 InnoDB 在大部分情况下都不会对异常进行回滚。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h3><p>死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象。若无外力作用，事务都将无法推进下去。解决死锁问题最简单的方式是不 要有等待，将任何的等待都转化为回滚，并且事务重新开始。毫无疑问，这的确可以避免死锁问题的产生。然而在线上环境中，这可能导致并发性能的下降，甚至任何一个事务都不能进行。而这所带来的问题远比死锁问题更为严重，因为这很难被发现并且浪费资源。</p>
<p>解决死锁问题最简单的一种方法是超时，即当两个事务互相等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。在 InnoDB 存储引擎中，参数 <code>innodb_lock_wait_timeout</code> 用来设置超时时间。</p>
<p>超时机制虽然简单，但是其仅通过超时后对事务进行回滚的方式来处理，或者说其是根据 FIFO 的顺序选择回滚对象。但被超时的事务所占权重比较大，如事务操作更新了很多行，占用了较多的 undo log，这时采用 FIFO 的方式，就显得不合适了，因为回滚这个事务的时间相对另一个事务所占用的时间可能会很多。</p>
<p>因此，除了超时机制，目前数据库还普遍采用 wait-for graph（等待图）的方式来进行死锁检测。较之超时的解决方案，这是一种更为主动的死锁检测方式。InnoDB 存储引擎也采用的这种方式。wait-for graph 要求数据库保存以下两种信息：</p>
<ul>
<li>锁的信息链表 </li>
<li>事务等待链表</li>
</ul>
<p>通过上述链表可以构造出一张图，而在这个图中若存在回路，就代表存在死锁，因此资源间相互发生等待。在 wait-for graph 中，事务为图中的节点。而在图中，事务 T1 指向 T2 边的定义为：事务 T1 等待事务 T2 所占用的资源，也就是事务之间在等待相同的资源，而事务 T1 发生在事务 T2 的后面。</p>
<p>假设当前事务和锁的状态如下图：</p>
<p><img src="/../../images/MySQL/mysql_locking_trx_lock.drawio.png" alt="img"></p>
<p>在 Transaction Wait Lists 中可以看到共有 4 个事务 t1、t2、t3、t4，故在 wait-for graph 中应有 4 个节点。而事务 t2 对 row1 占用 X 锁，事务 t1 对 row2 占用 S 锁。事务 t1 需要等待事务 t2 对 row1 的资源，因此在 wait-for graph 中有条边从节点 t1 指向节点 t2。事务 t2 需要等待事务 t1、t4 所占用的 row2 对象，故而存在节点 t2 到节点 t1、t4 的边。同样，存在节点 t3 到节点 t1、t2、t4 的边，因此最终的 wait-for graph 如下图：</p>
<p><img src="/../../images/MySQL/mysql_locking_wait_graph.drawio.png" alt="img"></p>
<p>可以发现存在回路 <code>(t1, t2)</code>，因此存在死锁。通过上述的介绍，可以发现 wait-for graph 是一种较为主动的死锁检测机制，在每个事务请求锁并发生等待时都会判断是否存在回路，若存在则有死锁。通常来说，InnoDB 存储引擎选择回滚 undo 量最小的事务。</p>
<p>wait-for graph 的死锁检测通常采用深度优先的算法实现，在 InnoDB 1.2 版本之前，都是采用递归方式实现。而从 1.2 版本开始，对 wait-for graph 的死锁检测进行了优化，将递归用非递归的方式实现，从而进一步提高了 InnoDB 存储引擎的性能。</p>
<p><strong>死锁示例</strong></p>
<p>如果程序是串行的，那么不可能发生死锁。死锁只存在于并发的情况，而数据库本身就是一个并发运行的程序，因此可能会发生死锁。下表的操作演示了死锁的一种经典的情况，即 A 等待 B， B 在等待 A，这种死锁问题被称为 AB-BA 死锁。</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>会话 A</th>
<th>会话 B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>mysql&gt; SELECT * FROM t WHERE a &#x3D; 1 FOR UPDATE;<br />******** 1 row ******** a: 1 1 row in set (0.00 sec)</td>
<td>BEGIN</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>mysql&gt; SELECT * FROM t WHERE a &#x3D; 2 FOR UPDATE;<br /> ******** 1 row ******** a: 2 1 row in set (0.00 sec)</td>
</tr>
<tr>
<td>4</td>
<td>mysql&gt; SELECT * FROM t WHERE a &#x3D; 2 FOR UPDATE; # 等待</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>mysql&gt; SELECT * FROM t WHERE a &#x3D; 1 FOR UPDATE;<br /> ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</td>
</tr>
</tbody></table>
<p>在上述操作中，会话 B 中的事务抛出了 1213 这个错误提示，即表示事务发生了死锁。死锁的原因是会话 A 和 B 的资源在互相等待。大多数的死锁 InnoDB 存储引擎本身可以侦测到，不需要人为干预。但是在上面的例子中，在会话 B 中的事务抛出死锁异常后，会话 A 中马上得到了记录 2 的这个资源，这其实是因为会话 B 中的事务发生了回滚，否则会话 A 中的事务是不可能得到该资源的。之前说过 InnoDB 存储引擎并不会回滚大部分的异常，但死锁除外。发现死锁后，InnoDB 存储引擎会马上回滚一个事务，这一点需要注意。因此如果在应用程序中捕获了 1213 这个错误，其实并不需要对其进行额外回滚。</p>
<p>此外还有另一种死锁，即当前事务持有了待插入记录的下一个记录的 X 锁，但是在等待队列中存在一个 S 锁的请求，则可能会发生死锁。来看一个例子，首先根据如下代码创建测试表 t，并导入一些数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> t (</span><br><span class="line">  a <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">INSERT INTO</span> t <span class="keyword">VALUES</span> (<span class="number">1</span>), (<span class="number">2</span>), (<span class="number">4</span>), (<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<p>下面演示两会话（会话 A 和会话 B）并发执行时发生死锁的过程：</p>
<table>
<thead>
<tr>
<th>时间</th>
<th>会话 A</th>
<th>会话 B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>BEGIN;</code></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td><code>BEGIN;</code></td>
</tr>
<tr>
<td>3</td>
<td><code>SELECT * FROM t WHERE a = 4 FOR UPDATE;</code></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td></td>
<td><code>SELECT * FROM t WHERE a &lt;= 4 LOCK IN SHARE MODE;</code><br>– 等待</td>
</tr>
<tr>
<td>5</td>
<td><code>INSERT INTO t VALUES (3);</code><br><code>ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</code></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td></td>
<td>– 事务获得锁，正常运行</td>
</tr>
</tbody></table>
<p>事务 A 在时间点 3：</p>
<p>执行 <code>SELECT * FROM t WHERE a = 4 FOR UPDATE;</code></p>
<p>这条语句会对主键值 a&#x3D;4 的记录加 X 锁。到此时刻，事务 A 持有对记录 (a&#x3D;4) 的 X 锁，且锁保持不释放（事务尚未提交或回滚）。</p>
<p>事务 B 在时间点 4：</p>
<p>执行 <code>SELECT * FROM t WHERE a &lt;= 4 LOCK IN SHARE MODE;</code></p>
<p>由于条件 a &lt;&#x3D; 4 会匹配到主键值 1, 2, 4 三条记录，因此事务 B 需要对这些记录的索引范围（Range）加 S 锁。其中，对 (a&#x3D;4) 那条记录上的 S 锁请求会因为事务 A 已经持有该行的 X 锁而被阻塞，导致事务 B 进入等待队列。</p>
<p>事务 A 在时间点 5：</p>
<p>执行 <code>INSERT INTO t VALUES (3);</code></p>
<p>插入新行 a&#x3D;3 时，InnoDB 需要在索引（聚簇索引）上为记录 3 所在位置加上插入意向锁（Gap Lock &#x2F; Next-key Lock）。由于 InnoDB 的聚簇索引按主键值顺序存储，此时 a&#x3D;3 属于介于 a&#x3D;2 与 a&#x3D;4 之间的间隙。</p>
<p>然而，事务 B 已在索引范围上对 (a &lt;&#x3D; 4) 加了 S 锁，并且正等待获取 (a&#x3D;4) 上的 S 锁。换句话说，此时索引上存在：</p>
<ul>
<li>事务 A：已对 a&#x3D;4 加了 X 锁，还需要对间隙 <code>(2, 4)</code> 加插入意向 X 锁，才能插入 a&#x3D;3。</li>
<li>事务 B：已对间隙 <code>(2, 4)</code>（更准确地说是对 a &lt;&#x3D; 4 范围）请求 S 锁，其中包括 (a&#x3D;2)、(a&#x3D;4) 以及它们之间的间隙。</li>
</ul>
<p><strong>为何形成死锁？</strong></p>
<ul>
<li>事务 B 正在等待 (a &#x3D; 4) 上的 S 锁，而当事务 A 在时间点 5 尝试插入 a&#x3D;3 时，InnoDB 会先对 (a &#x3D; 3) 的插入位置加 X 锁（Gap Lock 或 Next-key Lock）。由于事务 B 已对 (a &lt;&#x3D; 4) 这个范围中的间隙（包括 (2, 4)）持有 S 锁请求（还未获得，但已在等待队列中），所以此时：<ul>
<li>事务 A 需要等到 Gap Lock 获得，而 Gap Lock 又受限于事务 B 已在其上排队的 S 锁；</li>
<li>同时，事务 B 需要等到 (a &#x3D; 4) 上的 S 锁释放，而 (a &#x3D; 4) 由事务 A 持有 X 锁；</li>
</ul>
</li>
<li>这样就形成循环等待：<ul>
<li>事务 A 等待事务 B 在间隙 <code>(2, 4)</code> 上的 S 锁释放（因为事务 B 在关键范围上排队），</li>
<li>事务 B 等待事务 A 释放 (a &#x3D; 4) 上的 X 锁。</li>
</ul>
</li>
</ul>
<p>由于两者互相等待、谁都无法前进一步，InnoDB 判定为死锁。</p>
<p><strong>InnoDB 如何选择回滚？</strong></p>
<p>在常见的 AB-BA 死锁（即会话 A 等待会话 B 持有的资源，同时会话 B 等待会话 A 持有的资源）场景中，InnoDB 会回滚产生的事务中undo log 使用量最小的那个，以尽量减少回滚开销。</p>
<p>然而本例中的死锁类型不同：它属于插入意向锁与共享锁（Gap Lock&#x2F;S 锁）之间的循环等待。此时应回滚哪一个事务呢？</p>
<ul>
<li>事务 A：已持有 (a&#x3D;4) 的 X 锁，而正在尝试插入 a&#x3D;3（需要对间隙 <code>(2, 4)</code> 加 X 锁），此时这一步才触发死锁检测；</li>
<li>事务 B：已在时间点 4 提出对 a &lt;&#x3D; 4 范围的 S 锁请求，但尚未获得该锁，处于等待状态。</li>
</ul>
<p>InnoDB 在检测到此时的死锁后，会回滚 undo log 记录量最大的事务。对比：</p>
<ul>
<li>事务 A：已读取并锁定了整行 a&#x3D;4，其 undo log 可能包含对索引与行锁记录的修改；</li>
<li>事务 B：尚未真正获取任何锁（仅在等待）；其 undo log 体积更小。</li>
</ul>
<p><strong>排查死锁的简单流程</strong></p>
<ol>
<li>查看死锁日志 <code>show engine innodb status;</code></li>
<li>找出死锁对应的 SQL</li>
<li>分析这些 SQL 的加锁情况</li>
<li>模拟死锁的发生过程</li>
<li>分析死锁日志</li>
<li>分析死锁结果</li>
</ol>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><p>锁升级（Lock Escalation）是指将当前锁的粒度降低。举例来说，数据库可以把一个表的 1000 个行锁升级为一个页锁，或者将页锁升级为表锁。如果在数据库的设计中认为锁是一种稀有资源，而且想避免锁的开销，那么数据库中会频繁出现锁升级现象。</p>
<p>Microsoft SQL Server 数据库的设计认为锁是一种稀有的资源，在适合的时候会自动地将行、键或分项锁升级为更粗粒度的表级锁。这种升级保护了系统资源，防止系统使用太多的内存来维护锁，在一定程度上提高了效率。</p>
<p>在 Microsoft SQL Server 数据库中，由于锁是一种稀有的资源，因此锁升级会带来一定的效率提高。但是锁升级带来的一个问题却是因为锁粒度的降低而导致并发性能的降低。</p>
<p>InnoDB 存储引擎不存在锁升级的问题。因为其不是根据每个记录来产生行锁，相反，其根据每个事务访问的每个页对锁进行管理的，采用的是位图的方式。因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。</p>
<p>也就是说，在 InnoDB 中，每当一个事务要对某个页内的若干行加锁时，会在该页对应的 lock 对象（<code>lock_rec_t</code>）后面附加一个<strong>位图（bitmap）</strong>，用来表示该页内哪些行被锁住了。每条记录在页内有一个唯一的 <code>heap_no</code> 编号，对应到位图中的一个比特位。当事务锁定某行时，就将该行对应 <code>heap_no</code> 的位图位置置为 1。多个行的锁请求会共用同一个 lock 对象，通过设置不同的 bit 来记录多个行锁。该方式极大地减少了内存开销，避免了行级锁的逐个对象管理及锁升级问题。</p>
<p>假设一张表有 3,000,000 个数据页，每个页大约有 100 条记录，那么总共有 300,000,000 条记录。若有一个事务执行全表更新的 SQL 语句，则需要对所有记录加 X 锁。若根据每行记录产生锁对象进行加锁，并且每个锁占用 10 字节，则仅对锁管理就需要差不多 3 GB 的内存。而 InnoDB 存储引擎根据页进行加锁，并采用位图方式，假设每个页存储的锁信息占用 30 个字节，则锁对象仅需 90 MB 的内存。由此可见两者对于锁资源开销的差距之大。</p>
<h2 id="B-树索引中的锁"><a href="#B-树索引中的锁" class="headerlink" title="B+ 树索引中的锁"></a>B+ 树索引中的锁</h2><p>在 InnoDB 源码层面，B+ 树锁通常包含两种基本类型：</p>
<ul>
<li><strong>索引锁（Index Lock）</strong>：对应代码中的 <code>dict_index-&gt;lock</code>，用于保护整个 B+ 树索引结构，主要在结构修改（SMO）时使用。</li>
<li><strong>页锁（Page Lock）</strong>：对应 B+ 树中各数据页的锁变量，用于并发访问控制。非叶子节点页与叶子节点页都可以加锁。</li>
</ul>
<p>在 MySQL 5.6 版本中：</p>
<ol>
<li><strong>查询（SELECT）请求</strong><ul>
<li>首先对 B+ 树索引加一个共享锁（S LOCK），随后仅在找到目标叶子节点后，对该叶子页再次加 S LOCK，然后释放索引锁。</li>
</ul>
</li>
<li><strong>修改（UPDATE&#x2F;DELETE&#x2F;INSERT）请求</strong><ul>
<li>若仅修改叶子页数据：先对索引加 S LOCK，再在找到叶子页后对该叶子页加排它锁（X LOCK），然后释放索引锁。</li>
<li>若修改触发了结构变化（SMO）：<ol>
<li>对整个 B+ 树索引升级为 X LOCK；</li>
<li>执行 <code>btr_cur_search_to_nth_level</code> 定位页面；</li>
<li>在必要时对父节点直到根节点都施加 X LOCK，防止并发干扰。</li>
</ol>
</li>
<li><strong>非叶子节点并不显式加锁</strong>，这导致在 SMO 过程中，查询操作可能被阻塞，产生性能抖动。</li>
</ul>
</li>
</ol>
<p>从 MySQL 8.0 开始，引入了更细化的锁机制：</p>
<ol>
<li><strong>SX 锁（Shared eXclusive Intent Lock）</strong><ul>
<li>在可能发生结构修改时，用于表示预期会写入该分支但尚未真正改动，不会与 S LOCK 冲突，但会与 X LOCK 和其它 SX LOCK 冲突。</li>
</ul>
</li>
<li><strong>非叶子节点页锁</strong><ul>
<li>不再只锁叶子页，而对查找路径上所有非叶子节点页先后加锁（先父后子），实现所谓的锁耦合（Latch Coupling），从而缩小锁范围。</li>
</ul>
</li>
</ol>
<p><strong>B+ 树遍历锁机制：从根到叶</strong></p>
<p>下面以 MySQL 8.0+ 的机制为例，详细描述锁如何从根节点一路向下传递到叶子节点。</p>
<p>这里提前说明，索引锁和根节点的页锁不是一个东西。</p>
<p><strong>读操作</strong></p>
<ol>
<li>申请索引级共享锁（S LOCK on dict_index）<ul>
<li>客户端提交 <code>SELECT … FROM table WHERE key = … FOR UPDATE</code>&#x2F;<code>LOCK IN SHARE MODE</code> 时，InnoDB 会先对目标表的聚簇索引（<code>dict_index</code> 对象）加一个共享锁（S LOCK），用来保证当前索引结构不会被并发的结构修改操作破坏。</li>
</ul>
</li>
<li>从根节点开始逐级查找<ul>
<li>根节点会被先加页级 S LOCK。一旦对根页加锁成功，InnoDB 才继续往下访问子节点。</li>
<li>InnoDB 根据查询条件计算散列，然后通过 <code>btr_cur_search_to_nth_level()</code> 在根节点页中查找下一级页面指针。</li>
</ul>
</li>
<li>加锁子节点并逐步下降<ul>
<li>当从根节点读取到下一层节点的页号后，会释放根节点的 S LOCK，然后对该子节点页加 S LOCK，确保在当前事务继续寻找下一级时，不会遭到并发页分裂或合并等结构修改。</li>
<li>重复上述过程：在子节点加锁成功后，再释放父节点的锁，然后对孙子节点加 S LOCK……如此递归，直到叶子节点。</li>
<li>这种先子后父的锁耦合方式，保证了在任何时刻只有当前路径上的一部分节点被锁住，避免一次性锁定整棵树，提升并发性能。</li>
</ul>
</li>
<li>在叶子节点加锁并释放索引锁<ul>
<li>当定位到叶子节点后，对叶子页加上 S LOCK，并同时在页内搜索目标记录。若是 <code>FOR UPDATE</code>，则将对该记录使用 X LOCK（通过行锁实现）；若是 <code>LOCK IN SHARE MODE</code>，则使用 S LOCK。</li>
<li>此时可以释放最初的索引级共享锁（<code>dict_index-&gt;lock</code>），因为页锁已足以保证后续读取过程中不被结构修改破坏。</li>
</ul>
</li>
</ol>
<p><strong>写操作</strong></p>
<ol>
<li>申请索引级共享锁（S LOCK on <code>dict_index</code>）<ul>
<li>当执行 <code>UPDATE t SET col=… WHERE key=…</code> 时，InnoDB 依旧首先加索引级 S LOCK，防止在查找路径上结构变化。</li>
</ul>
</li>
<li>递归锁定路径上的非叶子节点<ul>
<li>执行与读场景相同的路径查找，但依次对每个非叶子节点页加 S LOCK（并在获得子节点锁后立即释放父节点锁），保证当前页不被分裂或重组删除。</li>
</ul>
</li>
<li>在叶子页加 X LOCK<ul>
<li>定位到叶子页后，加上一个排它锁（X LOCK），并在页内根据 <code>heap_no</code> 对应到位图将该行锁定。此时可释放索引级共享锁（<code>dict_index-&gt;lock</code>）。</li>
</ul>
</li>
<li>执行更新<ul>
<li>对目标记录进行写操作，如更新列值。若更新值导致插入新记录或页内空间不足，就会触发叶子页分裂，此时需要对分裂路径重新加锁。</li>
<li>如果触发了页分裂，则会将当前路径上涉及分裂的非叶子节点也升级为 SX LOCK 或 X LOCK，并相应地执行分裂操作。</li>
</ul>
</li>
<li>完成后释放锁<ul>
<li>事务结束时，InnoDB 会遍历该事务的 <code>trx_locks</code> 链表，逐个释放所有页锁和行锁。</li>
</ul>
</li>
</ol>
<p>这部分的具体内容可参考：<a href="/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/2025/01/25/%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/OLTP%20%E7%B4%A2%E5%BC%95/">OLTP 索引</a></p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/undefined/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/2024/11/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/IQ/" rel="prev" title="IQ">
      <i class="fa fa-chevron-left"></i> IQ
    </a></div>
      <div class="post-nav-item">
    <a href="/undefined/MySQL/2024/11/13/MySQL/MySQL%20%E6%9E%B6%E6%9E%84/" rel="next" title="MySQL 架构">
      MySQL 架构 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#lock-%E4%B8%8E-latch"><span class="nav-number">1.</span> <span class="nav-text">lock 与 latch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E9%97%AE%E9%A2%98"><span class="nav-number">2.</span> <span class="nav-text">锁问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%84%8F%E8%AF%BB"><span class="nav-number">2.1.</span> <span class="nav-text">脏读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">2.2.</span> <span class="nav-text">不可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A2%E5%A4%B1%E6%9B%B4%E6%96%B0"><span class="nav-number">2.3.</span> <span class="nav-text">丢失更新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#InnoDB-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E9%94%81"><span class="nav-number">3.</span> <span class="nav-text">InnoDB 存储引擎中的锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">锁的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="nav-number">3.2.</span> <span class="nav-text">一致性非锁定读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="nav-number">3.3.</span> <span class="nav-text">一致性锁定读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E9%95%BF%E4%B8%8E%E9%94%81"><span class="nav-number">3.4.</span> <span class="nav-text">自增长与锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E9%94%AE%E5%92%8C%E9%94%81"><span class="nav-number">3.5.</span> <span class="nav-text">外键和锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E"><span class="nav-number">4.</span> <span class="nav-text">阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%BB%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">死锁的概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="nav-number">6.</span> <span class="nav-text">锁升级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E4%B8%AD%E7%9A%84%E9%94%81"><span class="nav-number">7.</span> <span class="nav-text">B+ 树索引中的锁</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yihang Wei</p>
  <div class="site-description" itemprop="description">聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>English</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="">
      
        <option value="zh-CN" data-href="/undefined/MySQL/2024/11/08/MySQL/%E9%94%81/" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/undefined/MySQL/2024/11/08/MySQL/%E9%94%81/" selected="">
          English
        </option>
      
    </select>
  </div>

        
  <div class="beian"><a href="https://beian.miit.gov.cn/" rel="noopener" target="_blank">京ICP备2025131880号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yihang Wei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '50%',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: '#fff',
  backgroundColor: '#fff',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '明暗',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>

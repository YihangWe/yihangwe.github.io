<!DOCTYPE html>
<html lang="zh-CN,en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yihangwe.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
<meta property="og:type" content="website">
<meta property="og:title" content="EthanWeee">
<meta property="og:url" content="https://yihangwe.github.io/page/3/index.html">
<meta property="og:site_name" content="EthanWeee">
<meta property="og:description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yihang Wei">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yihangwe.github.io/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>EthanWeee</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><script>(function() {function calculateHeight(element) {let height = 0;const items = element.children;for (let i = 0; i < items.length; i++) {height += items[i].offsetHeight || 25;const child = items[i].querySelector(".nav-child");if (child && child.style.display !== "none") {height += calculateHeight(child);}}return height;}function generateToc(lang, container) {const content = document.getElementById(lang + "-content");if (!content) return;const headers = Array.from(content.querySelectorAll("h1, h2, h3, h4, h5, h6"));if (headers.length === 0) return;const ol = document.createElement("ol");ol.className = "nav";let currentLevel = 1;let currentOl = ol;let stack = [ol];let counters = [0, 0, 0, 0, 0, 0];headers.forEach((header, index) => {const level = parseInt(header.tagName[1]);counters[level - 1]++;for (let i = level; i < 6; i++) counters[i] = 0;const li = document.createElement("li");li.className = "nav-item nav-level-" + level;if (level === 1 && index === 0) {li.classList.add("active", "active-current");}const link = document.createElement("a");link.className = "nav-link";if (level === 1 && index === 0) link.classList.add("active");link.href = "#" + header.id;const numSpan = document.createElement("span");numSpan.className = "nav-number";numSpan.textContent = counters.slice(0, level).filter(n => n > 0).join(".");const textSpan = document.createElement("span");textSpan.className = "nav-text";textSpan.textContent = header.textContent;link.appendChild(numSpan);link.appendChild(document.createTextNode(" "));link.appendChild(textSpan);li.appendChild(link);if (level > currentLevel) {const newOl = document.createElement("ol");newOl.className = "nav-child";if (currentLevel === 1) {newOl.style.display = "block";stack[currentLevel - 1].lastElementChild.classList.add("active");}stack[currentLevel - 1].lastElementChild.appendChild(newOl);stack[level - 1] = newOl;currentOl = newOl;} else if (level < currentLevel) {currentOl = stack[level - 1];}currentOl.appendChild(li);currentLevel = level;});container.appendChild(ol);setTimeout(() => {const navHeight = calculateHeight(ol);ol.style.setProperty("--height", navHeight + "px");const navChilds = ol.getElementsByClassName("nav-child");Array.from(navChilds).forEach(child => {if (child.style.display === "block") {const childHeight = calculateHeight(child);child.style.setProperty("--height", childHeight + "px");}});}, 0);return ol;}function updateActiveHeading() {const activeLang = document.getElementById("en-content").style.display === "block" ? "en" : "zh";const content = document.getElementById(activeLang + "-content");const toc = document.getElementById(activeLang + "-toc");if (!content || !toc) return;const headers = Array.from(content.querySelectorAll("h1, h2, h3, h4, h5, h6"));const scrollPos = window.scrollY + window.innerHeight / 3;let activeHeader = null;for (let i = headers.length - 1; i >= 0; i--) {const header = headers[i];const headerTop = header.getBoundingClientRect().top + window.scrollY;if (headerTop <= scrollPos) {activeHeader = header;break;}}const links = toc.getElementsByClassName("nav-link");Array.from(links).forEach(link => {link.classList.remove("active");const parentLi = link.parentElement;if (parentLi) {parentLi.classList.remove("active", "active-current");}});if (activeHeader) {const activeLink = toc.querySelector(`a[href="#${activeHeader.id}"]`);if (activeLink) {activeLink.classList.add("active");let parent = activeLink.parentElement;while (parent && parent.classList) {if (parent.classList.contains("nav-item")) {parent.classList.add("active");if (parent.classList.contains("nav-level-1")) {parent.classList.add("active-current");}}parent = parent.parentElement;}}}}function initTippy() {document.querySelectorAll(".refplus-num").forEach((ref) => {if (ref._tippy) {ref._tippy.destroy();}let refid = ref.firstChild.href.replace(location.origin+location.pathname,"");let refel = document.querySelector(refid);if (!refel) return;let refnum = refel.dataset.num;let ref_content = refel.innerText.replace(`[${refnum}]`,"");tippy(ref, {content: ref_content,});});}function initToc() {const originalToc = document.querySelector(".post-toc-wrap");if (!originalToc || !document.getElementById("langToggle")) return;const tocContainer = document.createElement("div");tocContainer.className = "post-toc-wrap sidebar-panel sidebar-panel-active";const enToc = document.createElement("div");enToc.id = "en-toc";enToc.className = "post-toc motion-element";enToc.style.display = "block";const zhToc = document.createElement("div");zhToc.id = "zh-toc";zhToc.className = "post-toc motion-element";zhToc.style.display = "none";generateToc("en", enToc);generateToc("zh", zhToc);tocContainer.appendChild(enToc);tocContainer.appendChild(zhToc);originalToc.parentNode.replaceChild(tocContainer, originalToc);window.addEventListener("scroll", updateActiveHeading);setTimeout(updateActiveHeading, 0);}window.toggleLanguage = function() {const enContent = document.getElementById("en-content");const zhContent = document.getElementById("zh-content");const enToc = document.getElementById("en-toc");const zhToc = document.getElementById("zh-toc");const button = document.getElementById("langToggle");if (!enContent || !zhContent || !enToc || !zhToc || !button) return;const isEnglish = enContent.style.display === "block";enContent.style.display = isEnglish ? "none" : "block";zhContent.style.display = isEnglish ? "block" : "none";enToc.style.display = isEnglish ? "none" : "block";zhToc.style.display = isEnglish ? "block" : "none";button.querySelector(".button-text").textContent = isEnglish ? "Switch to English" : "切换中文";setTimeout(updateActiveHeading, 0);setTimeout(initTippy, 100);};document.addEventListener("DOMContentLoaded", function() {initToc();setTimeout(initTippy, 3000);});})();</script><style>.post-toc { transition: all 0.2s ease-in-out; }.post-toc .nav { padding-left: 0; }.post-toc .nav-child { padding-left: 1em; }.post-toc .nav-item { line-height: 1.8; }.post-toc .nav-link { color: #555; }.post-toc .nav-link:hover { color: #222; }.post-toc .nav-link.active { color: #fc6423; }.post-toc .active > .nav-link { color: #fc6423; }.post-toc .active-current > .nav-link { color: #fc6423; }</style><!-- hexo injector head_end end --><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EthanWeee</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN,en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/MySQL/2024/11/30/MySQL/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/MySQL/2024/11/30/MySQL/%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/" class="post-title-link" itemprop="url">备份与恢复</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-30 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-30T00:00:00-08:00">2024-11-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-23 14:18:57" itemprop="dateModified" datetime="2025-06-23T14:18:57-07:00">2025-06-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><p>数据库的备份与恢复是一项最基本的操作与工作。在意外情况下（如服务器宕机、磁盘损坏、RAID 卡损坏等）要保证数据不丢失，或者是最小程度地丢失，每个开发者应该时刻关心所负责的数据库备份情况。</p>
<p>可以根据不同的类型来划分备份的方法。根据备份的方法不同可以将备份分为：</p>
<ul>
<li>Hot Backup（热备）</li>
<li>Cold Backup（冷备）</li>
<li>Warm Backup（温备）</li>
</ul>
<p><strong>Hot Backup</strong> 是指数据库运行中直接备份，对正在运行的数据库操作没有任何的影响。这种方式在 MySQL 官方手册中称为 <strong>Online Backup（在线备份）</strong>。<strong>Cold Backup</strong> 是指备份操作是在数据库停止的情况下，这种备份最为简单，一般只需要复制相关的数据库物理文件即可。这种方式在 MySQL 官方手册中称为 <strong>Offline Backup（离线备份）</strong>。<strong>Warm Backup</strong> 备份同样是在数据库运行中进行的，但是会对当前数据库的操作有所影响，如加一个全局读锁以保证备份数据的一致性。</p>
<p>按照备份后文件的内容，备份又可以分为：</p>
<ul>
<li>逻辑备份</li>
<li>裸文件备份</li>
</ul>
<p>在 MySQL 数据库中，逻辑备份是指备份出的文件内容是可读的，一般是文本文件。内容一般是一条条 SQL 语句，或者是表内实际数据组成。如 mysqldump 和 <code>SELECT * INTO OUTFILE</code> 的方法。这类方法的好处是可以观察导出文件的内容，一般适用于数据库的升级、迁移等工作。但其缺点是恢复所需要的时间往往较长。</p>
<p>裸文件备份是指复制数据库的物理文件，既可以是在数据库运行中的复制（如 ibbackup, xtrabackup 这些工具），也可以是在数据库停止运行时直接的数据文件复制。这类备份的恢复时间往往较逻辑备份短很多。</p>
<p>若按照备份数据库的内容来分，备份又可以分为：</p>
<ul>
<li>完全备份</li>
<li>增量备份</li>
<li>日志备份</li>
</ul>
<p><strong>完全备份</strong> 是指对数据库进行一个完整的备份。<strong>增量备份</strong> 是指在上次完全备份的基础上，对下次更改的数据进行备份。<strong>日志备份</strong> 主要是指对 MySQL 数据库二进制日志的备份，通过对一个完全备份做完二进制日志的重做（replay）来完成数据库的 point-in-time 的恢复工作。MySQL 数据库复制（replication）的原理就是异步实时地将二进制日志重做传送并应用到从（slave&#x2F;standby）数据库。</p>
<p>对于 MySQL 数据库来说，官方没有提供真正的增量备份的方法，大部分是通过二进制日志完成增量备份的工作。这种备份较之真正的增量备份来说，效率还是很低的。假设有一个 100GB 的数据库，要通过二进制日志完成备份，可能同一个页面要执行十多次的 SQL 语句完成真正做的工作。但是对于真正的增量备份来说，只需要记录当前页或最后的检查点的 LSN，如果大于之前全备时的 LSN，则备份该页，否则不用备份，这大大加快了备份的速度和恢复的时间，同时这也是 xtrabackup 工具增量备份的原理。</p>
<p>此外还需要理解数据库备份的一致性，这种备份要求在备份的时候数据在这一时间点上是一致的。举例来说，在一个网络游戏中有一个玩家购买了道具，这个事务的过程是：先扣除相应的金钱，然后向其装备表中插入道具，确保扣费和得到道具是互相一致的。否则，在恢复时，可能出现金钱被扣除了而道具丢失的问题。</p>
<p>对于 InnoDB 存储引擎来说，因为其支持 MVCC 功能，因此实现一致的备份比较简单。用户可以先开启一个事务，然后导出一组相关的表，最后提交。当然用户的事务隔离级别必须设置为 <strong>REPEATABLE READ</strong>，这种做法就可以给出一个完美的一致性备份。然而这个方法的前提是需要用户事先设计应用程序。对于上述的购买道具的过程，不可以分为两个事务来完成，如一个完成扣费，一个完成道具的购买。若备份读操作发生在这两者之间，则由于逻辑设计的问题，导致备份出的数据依然不是一致的。</p>
<p>对于 mysqldump 备份工具来说，可以通过添加 <code>--single-transaction</code> 选项获得 InnoDB 存储引擎的一致性备份，原理和之前所说的相同，也就是，这时的备份是在一个执行时间很长的只读事务中完成的，来保证所有导出的表处于同一时间点的数据视图中。另外，对于 InnoDB 存储引擎的备份，务必加上 -<code>-single-transaction</code> 的选项。如果不加这个选项，mysqldump 会对每个表分别 <code>LOCK TABLES</code> 并导出，会导致数据之间不一致（因为表导出存在先后顺序，前面表导出完了，后面表导出前可能已经被修改）。</p>
<p>最后，任何时候都需要做好远程异地备份，也就是容灾的防范。只是同一机房的两台服务器的备份是远远不够的。</p>
<h2 id="冷备份"><a href="#冷备份" class="headerlink" title="冷备份"></a>冷备份</h2><p>对于 <strong>InnoDB 存储引擎</strong> 的冷备非常简单，只需要备份 MySQL 数据库的 frm 文件、共享表空间文件、独立表空间文件（<code>*.ibd</code>）、重做日志文件。另外建议定期备份 MySQL 数据库的配置文件 <code>my.cnf</code>，这样有利于恢复的操作。</p>
<p>通常我们会写一个脚本来进行冷备的操作，可能还会对备份完成的数据库进行打包和压缩。关键在于不要遗漏原本需要备份的物理文件，如共享表空间和重做日志文件，少了这些文件可能数据库都无法启动。另一种经常发生的情况是由于磁盘空间已满而导致的备份失败，我们可能习惯性地认为运行脚本的备份是没有问题的，少了检验的机制。</p>
<p>正如前面所说的，在同一台机器上对数据库进行冷备是远远不够的，至少还需要将本地产生的备份存放到一台远程的服务器中，确保不会因为本地数据库的宕机而影响备份文件的使用。</p>
<p>冷备的优点是：</p>
<ul>
<li>备份简单，只要复制相关文件即可。</li>
<li>备份文件易于在不同操作系统、不同 MySQL 版本上进行恢复。</li>
<li>恢复相当简单，只需要把文件恢复到指定位置即可。</li>
<li>恢复速度快，不需要执行任何 SQL 语句，也不需要重建索引。</li>
</ul>
<p>冷备的缺点是：</p>
<ul>
<li>InnoDB 存储引擎冷备的文件通常比逻辑文件大很多，因为表空间中存放着很多其他的数据，如 undo 区、插入缓冲等信息。</li>
<li>冷备也不总是可以轻易地跨平台。操作系统、MySQL 的版本、文件大小写敏感和浮点数格式都可能成为问题。</li>
</ul>
<h2 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h2><h3 id="mysqldump"><a href="#mysqldump" class="headerlink" title="mysqldump"></a>mysqldump</h3><p>mysqldump 是 MySQL 官方提供的逻辑备份工具，用于将数据库中的结构和数据导出为 SQL 语句或其它文本格式，便于恢复、迁移或复制库。它支持单库、多库、单表或全库的备份，也能生成 CSV、XML 等格式文件。导出的文件可以在目标服务器上直接重执行，从而重建原始数据库对象和数据。</p>
<p>基本语法：<code>mysqldump [连接选项] [备份选项] 库名 [表名...] &gt; 备份文件.sql</code></p>
<p>如果要备份单库，可使用：<code>mysqldump -u root -p --single-transaction mydb &gt; mydb_backup.sql</code></p>
<p>如果要备份多库，可使用：<code>mysqldump -u root -p --databases db1 db2 &gt; multi_backup.sql</code></p>
<p>如果要备份全库，可使用：<code>mysqldump -u root -p --all-databases &gt; alldb.sql</code></p>
<p>如果是备份单表并按条件导出，可使用：<code>mysqldump -u root -p mydb orders --where=&quot;order_date &gt;= &#39;2025-01-01&#39;&quot; &gt; orders_jan.sql</code></p>
<p>如果是流式压缩备份，可使用：<code>mysqldump -u root -p mydb | gzip &gt; mydb.sql.gz</code></p>
<p>如果要恢复数据，可使用：<code>mysql -u root -p mydb &lt; mydb_backup.sql</code></p>
<h3 id="mysqlpump"><a href="#mysqlpump" class="headerlink" title="mysqlpump"></a>mysqlpump</h3><p>mysqlpump 采用队列 + 线程模型，对象级并行：</p>
<ul>
<li><strong>队列</strong>：可通过 <code>--parallel-schemas</code> 创建多个队列，每个队列可绑定一个或多个数据库。<ul>
<li><strong>线程</strong>：在每个队列下可指定线程数（<code>--default-parallelism</code>），对同一队列内的对象（表、视图、存储过程等）并行导出。</li>
</ul>
</li>
</ul>
<p>导出对象为一系列可执行的 SQL 语句，包括 CREATE、INSERT、GRANT、CREATE TRIGGER&#x2F;EVENT 等，可跨平台重现数据库结构与数据。</p>
<p>支持对象过滤：通过 <code>--exclude-databases</code>、<code>--include-tables</code>、<code>--exclude-users</code> 等选项灵活选择导出范围。</p>
<p>如果要全库并行备份，可使用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysqlpump \</span><br><span class="line"> --default-parallelism=4 \</span><br><span class="line"> --parallel-schemas=2 \</span><br><span class="line"> --add-drop-database \</span><br><span class="line"> --routines --triggers --events \</span><br><span class="line"> --users \</span><br><span class="line"> --compress \</span><br><span class="line"> --exclude-databases=information_schema,performance_schema \</span><br><span class="line"><span class="meta prompt_"> &gt; </span><span class="language-bash">full_backup.sql.gz</span></span><br></pre></td></tr></table></figure>

<p>恢复的操作和 mysqldump 的方法一致。</p>
<h3 id="SELECT-…-INTO-OUTFILE"><a href="#SELECT-…-INTO-OUTFILE" class="headerlink" title="SELECT … INTO OUTFILE"></a>SELECT … INTO OUTFILE</h3><p><code>SELECT … INTO OUTFILE</code> 用于将查询结果直接写入服务器主机上的文件，生成的文件可用于后续的批量导入或数据交换。该语句创建的文件必须在服务器文件系统中不存在，并且需要具备 FILE 权限才可执行。</p>
<p>如果要导出为 CSV 格式，可使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer_id, firstname, surname</span><br><span class="line"><span class="keyword">INTO</span> OUTFILE <span class="string">&#x27;/var/lib/mysql-files/customers.csv&#x27;</span></span><br><span class="line">FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;,&#x27;</span></span><br><span class="line">OPTIONALLY ENCLOSED <span class="keyword">BY</span> <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果要恢复备份，可使用：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE <span class="string">&#x27;/var/lib/mysql-files/customers.csv&#x27;</span></span><br><span class="line"><span class="keyword">INTO</span> <span class="keyword">TABLE</span> mytable</span><br><span class="line">FIELDS TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\t&#x27;</span></span><br><span class="line">LINES TERMINATED <span class="keyword">BY</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysqlimport \</span><br><span class="line"> --local \              </span><br><span class="line"> --fields-terminated-by=&#x27;,&#x27; \</span><br><span class="line"> --fields-enclosed-by=&#x27;&quot;&#x27; \</span><br><span class="line"> --lines-terminated-by=&#x27;\r\n&#x27; \</span><br><span class="line"> -u 用户 -p 数据库名 /var/lib/mysql-files/customers.csv</span><br></pre></td></tr></table></figure>

<h2 id="二进制日志的备份"><a href="#二进制日志的备份" class="headerlink" title="二进制日志的备份"></a>二进制日志的备份</h2><p>二进制日志是 MySQL 实现 point-in-time 恢复和异步复制的关键：</p>
<p>point-in-time 恢复：在发生故障后，可以将完全备份与二进制日志配合，重放指定时间段或位置的变更，实现回滚到任意时间点。<br>复制：主库将写入的二进制日志发送给从库，从库重放日志以保持数据同步。</p>
<p>默认情况下 MySQL 并不启用二进制日志，必须在 <code>my.cnf</code> 中添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log-bin = mysql-bin</span><br></pre></td></tr></table></figure>

<p>仅启用 log-bin 不够保险，建议在 <code>my.cnf</code> 中也加上：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">log<span class="operator">-</span>bin <span class="operator">=</span> mysql<span class="operator">-</span>bin</span><br><span class="line">sync_binlog <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">innodb_support_xa <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>sync_binlog=1</code>：每次提交时强制将二进制日志刷盘，防止故障时丢失已提交的事务。</p>
<p><code>innodb_support_xa=1</code>：开启 InnoDB 的 XA（分布式事务）支持，保证 binlog 与 InnoDB redo-log 在发生崩溃恢复时的一致性。</p>
<p>在备份二进制日志文件前，可通过 FLUSH LOGS 关闭当前日志文件并新建一个 binlog 文件，便于把之前那些日志一起备份。之后将 <code>mysql-bin.00000*</code> 等文件拷贝到安全位置，与完全备份一起存档。</p>
<p><strong>恢复二进制日志</strong></p>
<p><code>shell&gt; mysqlbinlog [options] mysql-bin.000001 | mysql -u root -p test</code> 可以将指定日志内容通过管道重放到目标库 test。<br>如果要同时恢复多文件，可以使用：<code>shell&gt; mysqlbinlog mysql-bin.00000[1-10] | mysql -u root -p test</code></p>
<p>先导出再 SOURCE 导入：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell<span class="operator">&gt;</span> mysqlbinlog mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">&gt;</span> <span class="operator">/</span>tmp<span class="operator">/</span>stmts.sql</span><br><span class="line">shell<span class="operator">&gt;</span> mysqlbinlog mysql<span class="operator">-</span>bin<span class="number">.000002</span> <span class="operator">&gt;&gt;</span> <span class="operator">/</span>tmp<span class="operator">/</span>stmts.sql</span><br><span class="line">shell<span class="operator">&gt;</span> mysql <span class="operator">-</span>u root <span class="operator">-</span>p <span class="operator">-</span>e &quot;SOURCE /tmp/stmts.sql&quot;</span><br></pre></td></tr></table></figure>

<p>我们也可以指定恢复的起始点：</p>
<p>按照偏移量：<code>mysqlbinlog --start-position=107856 mysql-bin.000001 | mysql -u root -p test</code></p>
<p>按照时间：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog <span class="comment">--start-datetime=&quot;2025-06-14 12:00:00&quot; \</span></span><br><span class="line">       			<span class="comment">--stop-datetime=&quot;2025-06-14 18:00:00&quot; \</span></span><br><span class="line">       			mysql<span class="operator">-</span>bin<span class="number">.000001</span> <span class="operator">|</span> mysql <span class="operator">-</span>u root <span class="operator">-</span>p test</span><br></pre></td></tr></table></figure>

<p>偏移量和时间选项的效果类似，都能实现仅重放二进制日志的部分内容。</p>
<h2 id="热备份"><a href="#热备份" class="headerlink" title="热备份"></a>热备份</h2><h3 id="ibbackup"><a href="#ibbackup" class="headerlink" title="ibbackup"></a>ibbackup</h3><p>ibbackup 是 InnoDB 存储引擎官方提供的热备工具，可以同时备份 MyISAM 存储引擎和 InnoDB 存储引擎表。对于 InnoDB 存储引擎表，其备份工作原理如下：</p>
<ol>
<li>记录备份开始时，InnoDB 存储引擎重做日志文件检查点的 LSN。</li>
<li>复制共享表空间文件以及独立表空间文件。</li>
<li>记录复制完表空间文件后，InnoDB 存储引擎重做日志文件检查点的 LSN。</li>
<li>复制在备份时产生的重做日志。</li>
</ol>
<p>对于事务型数据库，如 Microsoft SQL Server 数据库和 Oracle 数据库，热备的原理大致相同。可以发现，在备份期间不会对数据库本身有任何影响，所做操作只是复制数据库文件，因此任何对数据库的正常操作都是允许的，不会被阻塞。</p>
<p>ibbackup 的优点有：</p>
<ul>
<li>在线备份，不阻塞任何 SQL 语句。</li>
<li>备份性能好，实质上是复制数据库文件和重做日志文件。</li>
<li>支持压缩备份，通过选项可实现不同级别的压缩。</li>
<li>跨平台支持，可运行于 Linux、Windows 及主流 UNIX 平台。</li>
</ul>
<p>ibbackup 对 InnoDB 存储引擎表的恢复步骤为：</p>
<ol>
<li>恢复表空间文件。</li>
<li>应用重做日志文件。</li>
</ol>
<p>ibbackup 提供了一种高性能的热备方式，是 InnoDB 存储引擎备份的首选方式。不过它是收费软件，并非免费。好在开源社区力量强大，Percona 公司推出了开源、免费的 XtraBackup 热备工具，它不仅实现了 ibbackup 的所有功能，还扩展了真正的增量备份能力。因此，更好的选择是使用 XtraBackup 来完成热备工作。</p>
<p>XtraBackup 文档请参考：<a target="_blank" rel="noopener" href="https://docs.percona.com/percona-xtrabackup/8.4/">https://docs.percona.com/percona-xtrabackup/8.4/</a></p>
<h2 id="快照备份"><a href="#快照备份" class="headerlink" title="快照备份"></a>快照备份</h2><p>MySQL 数据库本身不支持快照功能，因此快照备份是指通过文件系统支持的快照功能对数据库进行备份。备份的前提是将所有数据库文件放在同一个文件分区中，然后对该分区进行快照操作。支持快照功能的文件系统和设备包括 FreeBSD 的 UFS 文件系统、Solaris 的 ZFS 文件系统、GNU&#x2F;Linux 的逻辑管理器（Logical Volume Manager，LVM）等。这里以 LVM 为例进行介绍。</p>
<p>LVM 是 LINUX 系统下对磁盘分区进行管理的一种机制。LVM 在硬盘和分区之上建立一个逻辑层，来提高磁盘分区管理的灵活性。管理员可以通过 LVM 系统轻松管理磁盘分区，例如，将若干个磁盘分区连接为一个整体的卷组（Volume Group），形成一个存储池。管理员可以在卷组上随意创建逻辑卷（Logical Volumes），并进一步在逻辑卷上创建文件系统。管理人员通过 LVM 可以方便地调整卷组的大小，并且可以对磁盘存储按照组的方式进行命名、管理和分配。简单地说，用户可以通过 LVM 由物理块设备（如硬盘等）创建物理卷，由一个或多个物理卷创建卷组，最后从卷组中创建任意个逻辑卷（不超过卷组大小），如下图所示。</p>
<p><img src="/../../images/MySQL/mysql_backup_snap.png" alt="img"></p>
<p>下图显示了由多块物理磁盘分区组成的逻辑卷 LV0。</p>
<p><img src="/../../images/MySQL/mysql_backup_LV0.drawio.png" alt="img"></p>
<ul>
<li><strong>Physical disk 0</strong> 拥有分区 <code>/dev/hda1</code>, <code>/dev/hda2</code>, <code>/dev/hda3</code>, <code>/dev/hda4</code>；</li>
<li><strong>Physical disk 1</strong> 拥有分区 <code>/dev/hdb</code>；</li>
<li><strong>Physical disk 2</strong> 拥有分区 <code>/dev/hdd</code>。</li>
</ul>
<p>这些所有物理分区一起被加入到卷组 VG0 中，VG0 上划分出一个逻辑卷 LV0（图中左侧已分配区域），其余空间则作为 free space（图中右侧虚线区域）可供以后创建更多逻辑卷或扩展现有逻辑卷使用。</p>
<p>LVM 使用了写时复制（Copy-on-write）技术来创建快照。当创建一个快照时，仅复制原始卷中数据的元数据，并不会有数据的物理操作，因此快照的创建过程是非常快的。当快照创建完成，原始卷上有写操作时，快照会跟踪原始卷块的改变，将要改变的数据在改变之前复制到快照预留的空间里，因此这个原理的实现叫做写时复制。而对于快照的读取操作，如果读取的数据块是创建快照后没有修改过的，那么会将读取操作直接定向到原始卷上；如果读取的是已修改过的块，则将读取保存在快照中该块在原始卷上改变之前的数据。因此，采用写时复制机制保证了读取快照时得到的数据与快照创建时一致。</p>
<p>下图显示了 LVM 的快照读取，可见 B 区块被修改了，因此历史数据放入了快照区域。读取快照数据时，A、C、D 块还是从原有卷中读取，而 B 块就需要从快照读取了。</p>
<p><img src="/../../images/MySQL/mysql_backup_LVM.drawio.png" alt="img"></p>
<p>快照在最初创建时总是很小，当数据源卷的数据不断被修改时，这些数据才会放入快照空间，这时快照的大小才会慢慢增大。</p>
<p>为了让快照包含所有必要的数据，只要把 InnoDB 的所有相关文件（共享表空间文件、独立表空间文件、redo log 文件等）都放在同一个逻辑卷里。创建快照时，就会对整个逻辑卷进行一次时间点一致性的镜像。</p>
<p>在创建和使用 LVM 快照备份时，MySQL &#x2F; InnoDB 不需要停机，应用仍可以继续正常读写。虽然备份过程中还有写操作在往磁盘上提交，但快照机制会保证备份那一刻的数据完整性，不会捕获到部分写入的脏状态。</p>
<p>当你用 LVM 快照恢复文件后，InnoDB 会像意外断电重启那样：自动扫描数据页和 redo log，决定哪些事务需要重做或回滚，最后恢复到一个一致的、可用的数据库状态。因此，用 LVM 快照做备份，恢复后就像给数据库做了一次意外重启，但数据完全一致且不会丢失已提交的事务。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>复制（replication）是 MySQL 数据库提供的一种高可用高性能的解决方案，一般用来建立大型的应用。总体来说，replication 的工作原理分为以下 3 个步骤：</p>
<p>1）主服务器把数据更改记录到二进制日志中。</p>
<p>2）从服务器把主服务器的二进制日志复制到自己的中继日志（relay log）中。</p>
<p>3）从服务器重做中继日志中的日志项，把更改应用到自己的数据库上，以达到数据的最终一致性。</p>
<p>复制的工作原理并不复杂，其实就是一个完全备份加上二进制日志备份的还原。不同的是这个二进制日志的还原操作基本上实时在进行中。这里特别需要注意的是，复制不是完全实时地进行同步，而是异步实时。这中间存在主从服务器之间的执行延时，如果主服务器的压力很大，则可能导致主从服务器延时较大。复制的工作原理如下图所示。</p>
<p><img src="/../../images/MySQL/mysql_replic_ms.drawio.png" alt="img"></p>
<p>从服务器有 2 个线程，一个是 I&#x2F;O 线程，负责读取主服务器的二进制日志，并将其保存为中继日志；另一个是 SQL 线程，复制执行中继日志。因此如果查看一个从服务器的状态，应该可以看到类似如下内容：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">FULL</span> PROCESSLIST\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">  Id: <span class="number">1</span></span><br><span class="line">  <span class="keyword">User</span>: <span class="keyword">system</span> <span class="keyword">user</span></span><br><span class="line">  Host:</span><br><span class="line">  db: <span class="keyword">NULL</span></span><br><span class="line">	Command: <span class="keyword">Connect</span></span><br><span class="line">  <span class="type">Time</span>: <span class="number">6501</span></span><br><span class="line"> 	State: Waiting <span class="keyword">for</span> master <span class="keyword">to</span> send event</span><br><span class="line">  Info: <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">2.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">  Id: <span class="number">2</span></span><br><span class="line">  <span class="keyword">User</span>: <span class="keyword">system</span> <span class="keyword">user</span></span><br><span class="line">  Host:</span><br><span class="line">  db: <span class="keyword">NULL</span></span><br><span class="line">	Command: <span class="keyword">Connect</span></span><br><span class="line">  <span class="type">Time</span>: <span class="number">0</span></span><br><span class="line"> 	State: Has read <span class="keyword">all</span> relay log; waiting <span class="keyword">for</span> the slave I<span class="operator">/</span>O thread <span class="keyword">to</span> <span class="keyword">update</span> it</span><br><span class="line">  Info: <span class="keyword">NULL</span></span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">3.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">  Id: <span class="number">206</span></span><br><span class="line">  <span class="keyword">User</span>: root</span><br><span class="line">  Host: localhost</span><br><span class="line">  db: <span class="keyword">NULL</span></span><br><span class="line">	Command: Query</span><br><span class="line">  <span class="type">Time</span>: <span class="number">0</span></span><br><span class="line"> 	State: <span class="keyword">NULL</span></span><br><span class="line">  Info: <span class="keyword">SHOW</span> <span class="keyword">FULL</span> PROCESSLIST</span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看到 ID 为 1 的线程就是 I&#x2F;O 线程，当前的状态是等待主服务器发送二进制日志。 </p>
<p>ID 为 2 的线程是 SQL 线程，负责读取中继日志并执行。目前的状态是已读取所有的中继日志，等待中继日志被 I&#x2F;O 线程更新。 </p>
<p>在 replication 的主服务器上应该可以看到一个线程负责发送二进制日志，类似内容如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> <span class="keyword">FULL</span> PROCESSLIST\G </span><br><span class="line">…… </span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">65.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> </span><br><span class="line">  Id: <span class="number">26541</span> </span><br><span class="line">  <span class="keyword">User</span>: rep </span><br><span class="line">  Host: <span class="number">192.168</span><span class="number">.190</span><span class="number">.98</span>:<span class="number">39549</span> </span><br><span class="line">  db: <span class="keyword">NULL</span> </span><br><span class="line">	Command: Binlog Dump </span><br><span class="line">  <span class="type">Time</span>: <span class="number">6857</span> </span><br><span class="line"> 	State: Has sent <span class="keyword">all</span> binlog <span class="keyword">to</span> slave; waiting <span class="keyword">for</span> binlog <span class="keyword">to</span> be updated </span><br><span class="line">  Info: <span class="keyword">NULL</span> </span><br><span class="line">…… </span><br></pre></td></tr></table></figure>

<p>之前提到 MySQL 的复制是异步实时的，并非完全的主从同步。若用户要想得知当前的延迟，可以通过命令 <code>SHOW SLAVE STATUS</code> 和 <code>SHOW MASTER STATUS</code> 得知。</p>
<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> SLAVE STATUS\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">   Slave_IO_State: Waiting <span class="keyword">for</span> master <span class="keyword">to</span> send event</span><br><span class="line">   Master_Host: <span class="number">192.168</span><span class="number">.190</span><span class="number">.10</span></span><br><span class="line">   Master_User: rep</span><br><span class="line">   Master_Port: <span class="number">3306</span></span><br><span class="line">   Connect_Retry: <span class="number">60</span></span><br><span class="line">   Master_Log_File: mysql<span class="operator">-</span>bin<span class="number">.000007</span></span><br><span class="line">   Read_Master_Log_Pos: <span class="number">555176471</span></span><br><span class="line">   Relay_Log_File: gamedb<span class="operator">-</span>relay<span class="operator">-</span>bin<span class="number">.000048</span></span><br><span class="line">   Relay_Log_Pos: <span class="number">224355889</span></span><br><span class="line">   Relay_Master_Log_File: mysql<span class="operator">-</span>bin<span class="number">.000007</span></span><br><span class="line">   Slave_IO_Running: Yes</span><br><span class="line">   Slave_SQL_Running: Yes</span><br><span class="line">   Replicate_Do_DB:</span><br><span class="line">   Replicate_Ignore_DB:</span><br><span class="line">   Replicate_Do_Table:</span><br><span class="line">   Replicate_Ignore_Table:</span><br><span class="line">   Replicate_Wild_Do_Table:</span><br><span class="line">	 Replicate_Wild_Ignore_Table: mysql.<span class="operator">%</span>,DBA.<span class="operator">%</span></span><br><span class="line">   Last_Errno: <span class="number">0</span></span><br><span class="line">   Last_Error:</span><br><span class="line">   Skip_Counter: <span class="number">0</span></span><br><span class="line">   Exec_Master_Log_Pos: <span class="number">555176471</span></span><br><span class="line">   Relay_Log_Space: <span class="number">224356045</span></span><br><span class="line">   Until_Condition: <span class="keyword">None</span></span><br><span class="line">   Until_Log_File:</span><br><span class="line">   Until_Log_Pos: <span class="number">0</span></span><br><span class="line">   Master_SSL_Allowed: <span class="keyword">No</span></span><br><span class="line">   Master_SSL_CA_File:</span><br><span class="line">   Master_SSL_CA_Path:</span><br><span class="line">   Master_SSL_Cert:</span><br><span class="line">   Master_SSL_Cipher:</span><br><span class="line">   Master_SSL_Key:</span><br><span class="line"> 	 Seconds_Behind_Master: <span class="number">0</span></span><br><span class="line">	 Master_SSL_Verify_Server_Cert: <span class="keyword">No</span></span><br><span class="line">   Last_IO_Errno: <span class="number">0</span></span><br><span class="line">   Last_IO_Error:</span><br><span class="line">   Last_SQL_Errno: <span class="number">0</span></span><br><span class="line">   Last_SQL_Error:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>以上结果中的各个字段的含义如下所示：</p>
<table>
<thead>
<tr>
<th><strong>变量</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Slave_IO_State</td>
<td>当前 I&#x2F;O 线程的状态，此例为 “Waiting for master to send event”（等待主库发送新的 binlog 事件）</td>
</tr>
<tr>
<td>Master_Log_File</td>
<td>当前从库正在读取的主库 binlog 文件名，本例为 mysql-bin.000007</td>
</tr>
<tr>
<td>Read_Master_Log_Pos</td>
<td>从库已读取到的主库 binlog 偏移位置（字节）；本例 555176471 表示已读入约 529 MB（555176471&#x2F;1024²）</td>
</tr>
<tr>
<td>Relay_Master_Log_File</td>
<td>从库中继日志对应的主库 binlog 文件名</td>
</tr>
<tr>
<td>Relay_Log_File</td>
<td>当前写入的中继日志文件名</td>
</tr>
<tr>
<td>Relay_Log_Pos</td>
<td>已执行到中继日志的偏移位置（字节）</td>
</tr>
<tr>
<td>Slave_IO_Running</td>
<td>从库 I&#x2F;O 线程运行状态，YES 表示正常</td>
</tr>
<tr>
<td>Slave_SQL_Running</td>
<td>从库 SQL 线程运行状态，YES 表示正常</td>
</tr>
<tr>
<td>Exec_Master_Log_Pos</td>
<td>SQL 线程已执行到的主库 binlog 偏移位置；Read_Master_Log_Pos - Exec_Master_Log_Pos 即 I&#x2F;O 与 SQL 线程之间的“字节延迟”</td>
</tr>
</tbody></table>
<p><code>SHOW MASTER STATUS</code> 可以用来查看主服务器中二进制日志的状态，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> MASTER STATUS\G</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line"> File: mysql<span class="operator">-</span>bin<span class="number">.000007</span></span><br><span class="line"> Position: <span class="number">606181078</span></span><br><span class="line"> Binlog_Do_DB:</span><br><span class="line"> Binlog_Ignore_DB:</span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，当前二进制日志记录了偏移量 606181078 的位置，该值减去这一时间点时从服务器上的 <code>Read_Master_Log_Pos</code>，就可以得知 I&#x2F;O 线程的延时。</p>
<p>，用户不应仅监控从服务器上 I&#x2F;O 线程和 SQL 线程是否运行正常，同时也应监控从服务器与主服务器之间的延迟，确保从服务器上的数据尽可能接近主服务器上的状态。</p>
<h3 id="快照-复制的备份架构"><a href="#快照-复制的备份架构" class="headerlink" title="快照 + 复制的备份架构"></a>快照 + 复制的备份架构</h3><p>复制可以用来作为备份，但功能不仅限于备份，其主要功能如下： </p>
<ul>
<li>数据分布。由于 MySQL 数据库提供的复制并不需要很大的带宽要求，因此可以在不同的数据中心之间实现数据的复制。 </li>
<li>读取的负载平衡。通过建立多个从服务器，可将读取平均地分布到这些从服务器中，并且减少了主服务器的压力。一般通过 DNS 的 Round-Robin 和 Linux 的 LVS 功能都可以实现负载平衡。 </li>
<li>数据库备份。复制对备份很有帮助，但是从服务器不是备份，不能完全代替备份。 </li>
<li>高可用性和故障转移。通过复制建立的从服务器有助于故障转移，减少故障的停机时间和恢复时间。</li>
</ul>
<p>可见，只是用复制来进行备份是远远不够的。也就是说，<strong>仅靠主从复制无法完全防护数据丢失或误操作</strong>，需要结合<strong>从库的存储快照</strong>和<strong>二进制日志重放</strong>来实现对任意时间点的恢复与一致性保障。</p>
<p>假设当前应用采用了主从的复制架构，从服务器作为备份。此时，一个开发人员执行了误操作，如 <code>DROP DATABASE</code> 或 <code>DROP TABLE</code>，这时从服务器也跟着运行了。用户怎样从从服务器进行恢复呢？ </p>
<p>因此，一个比较好的方法是通过对从服务器上的数据库所在分区做快照，以此来避免误操作对复制造成影响。当发生主服务器上的误操作时，只需要将从服务器上的快照进行恢复，然后再根据二进制日志进行 point-in-time 的恢复即可。因此快照 + 复制的备份架构如下图所示。 </p>
<p><img src="/../../images/MySQL/mysql_replic_snap_binlog.drawio.png" alt="img"></p>
<p>还有一些其他的方法来调整复制，比如采用延时复制，即间歇性地开启从服务器上的同步，保证大约一小时的延时，可对抗误操作。这的确也是一个方法，只是数据库在高峰和非高峰期间每小时产生的二进制日志量是不同的，用户很难精确地控制。另外，这种方法也不能完全起到对误操作的防范作用。 </p>
<p>此外，建议在从服务器上启用 read-only 选项，这样能保证从服务器上的数据仅与主服务器进行同步，避免其他线程修改数据。如： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">read-only</span><br></pre></td></tr></table></figure>

<p>在启用 read-only 选项后，如果操作从服务器的用户没有 SUPER 权限，则对从服务器进行任何的修改操作会抛出一个错误，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT INTO</span> z <span class="keyword">SELECT</span> <span class="number">2</span>; </span><br><span class="line">ERROR <span class="number">1290</span> (HY000): The MySQL server <span class="keyword">is</span> <span class="keyword">running</span> <span class="keyword">with</span> the <span class="comment">--read-only option so it cannot execute this statement</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN,en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/MySQL/2024/11/26/MySQL/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/MySQL/2024/11/26/MySQL/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/" class="post-title-link" itemprop="url">分库分表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-26 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-26T00:00:00-08:00">2024-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-22 15:58:26" itemprop="dateModified" datetime="2025-06-22T15:58:26-07:00">2025-06-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><p>分库分表主要是为了解决单库单表在海量数据和高并发场景下的性能瓶颈：当数据量达到千万级甚至亿级时，单表查询效率和索引更新速度都会明显下降，备份恢复也变得极其缓慢；而在高并发写入时，单实例的 CPU、内存、I&#x2F;O 资源易成为瓶颈，锁竞争也会导致事务阻塞。通过将大表拆成多张子表、或将数据分散到多个数据库实例，不仅能降低单表、单库的数据规模，提升读写性能，还能分散并发压力、减少锁冲突，从而显著提高系统的可用性和扩展能力。</p>
<p>垂直分库通过将不同业务模块或功能独立到各自的数据库，既降低了数据之间的耦合度，又提升了整体可用性；水平分库则将同一业务的数据按一定策略分散到多台实例，分担了单库的 CPU、I&#x2F;O 和网络压力；垂直分表是把表中不同类型的数据拆分到多张表中，进一步削弱耦合；水平分表则把一张大表按范围或哈希划分成多张子表，从而减少索引深度并加快查询。</p>
<p>若仍使用单库单表模式，会因热点数据频繁访问导致缓冲区不足、磁盘 I&#x2F;O 激增，又因大量请求而引发网络带宽瓶颈，此外 SQL 处理也会占用过多 CPU 资源，最终形成性能瓶颈。分库分表的核心思想就是通过分散存储，将单一数据库或表的数据规模控制在可承载范围内，进而显著缓解 I&#x2F;O、CPU 和网络方面的压力。</p>
<h2 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h2><h3 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h3><p>垂直拆分主要包括两种形式：<strong>垂直分库</strong>和<strong>垂直分表</strong>。其中，垂直分库是以表为单位、根据业务模块将不同的表拆分到各自独立的数据库实例中，使得每个库只包含某一类业务的表，从而降低数据耦合度并提升可用性；而垂直分表则是以字段为依据，将同一张宽表中访问频次不同或性质相异的字段拆分到多张子表，通过主键—外键关联保持数据完整性，以减小单表宽度、优化查询性能。在实践中，垂直分库常用于按业务边界隔离数据，而垂直分表则侧重于对单表内部结构的精细化拆分，两者结合能够更好地满足系统的可扩展性与维护性需求。</p>
<p><img src="/../../images/MySQL/mysql_partition_v.drawio.png" alt="img"></p>
<h3 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h3><p>水平拆分是一种以<strong>行</strong>为单位对数据进行切割的策略：水平分库是将同一表的若干行数据按照某种分片键（如用户ID范围或哈希）分散到多个数据库实例，每个实例存储一部分数据，从而分担 CPU、I&#x2F;O 和网络负载；而水平分表则是在同一数据库实例内部将表数据行按相同策略分布到多张结构相同的子表中，以减少单表的索引层数，提升查询性能和并发处理能力。无论是分库还是分表，都可通过范围切片、哈希切片或列表切片等算法来保证数据的均衡分布，进一步降低锁竞争与热点访问问题。</p>
<p>在业界，这种做法通常也被称为分片（sharding），每个分片可以是独立的数据存储节点。此外，在云服务环境下，水平分区是实现水平扩展（scale-out）的核心方式，通过动态增加分片或实例来处理更大规模的请求和数据量；它还能与读写分离、缓存策略等机制结合，共同构建高可用、高性能的数据库架构。</p>
<p><img src="/../../images/MySQL/mysql_partition_h.drawio.png" alt="img"></p>
<h3 id="水平分表的路由方式"><a href="#水平分表的路由方式" class="headerlink" title="水平分表的路由方式"></a>水平分表的路由方式</h3><p>要实现水平分表，必须设计一个路由策略，根据<strong>分片键</strong>（Sharding Key）决定每条记录应写入哪张子表。理想的分片键应该具备以下特征：</p>
<p>一是<strong>高区分度</strong>，使数据均匀分布，避免某些表过热或过载；</p>
<p>二是<strong>查询频率高</strong>，优先选取常在 WHERE 条件中出现的字段，以确保绝大多数查询能直接定位到目标表，提升查询效率；</p>
<p>三是<strong>写入频率高</strong>，将频繁更新或插入的字段作为分片键，有助于将写负载均衡地分散到各个子表，从而减少单表写入瓶颈。</p>
<p>范围路由、哈希路由和配置路由是水平分表中最常用的三种策略。</p>
<p>范围路由通过将分片键按值的连续区间映射到不同的表，例如按时间戳或订单号切分，优势在于实现简单且可以平滑扩容，但容易出现部分分片数据过多的倾斜问题。</p>
<p><img src="/../../images/MySQL/mysql_partition_range.drawio.png" alt="img"></p>
<p>哈希路由则对分片键取哈希值并取模分表，可以较均匀地分散数据，避免单表热点，但执行范围查询时需要访问多个分片，查询性能有所下降。</p>
<p><img src="/../../images/MySQL/mysql_partition_hash.drawio.png" alt="img"></p>
<p>配置路由则通过维护一张映射表，显式指定每个分片键对应的目标表，灵活性最高，能够应对分片键分布不均或规则多变的场景，但需要额外的配置表来管理路由映射，运维成本和复杂度也相对更高。</p>
<p><img src="/../../images/MySQL/mysql_partition_route.drawio.png" alt="img"></p>
<p>以上的路由方式可以根据场景的不同组合使用，比如：首先根据业务维度（如订单月份）将数据划分到不同的<strong>分组</strong>，每个分组再映射到若干<strong>物理节点</strong>，形成按月分组的“范围切分”策略。然后在每个分组内部，对分片键（如 orderId）计算哈希并取模，将其均匀分配到该组的各节点上，兼顾了哈希路由的负载均衡效果。</p>
<h3 id="不停机扩容"><a href="#不停机扩容" class="headerlink" title="不停机扩容"></a>不停机扩容</h3><p>不停机扩容通常分为三个阶段，以确保旧库和新库在业务不中断的情况下平滑过渡。</p>
<p>第一阶段是<strong>在线双写、老库查询</strong>：在此阶段，先在新环境中建立与旧库完全相同的库表结构，然后将所有新增写操作同时写入旧库和新库，业务查询仍然走旧库；接着，通过专用迁移程序对旧库中的历史数据进行全量迁移，并通过定时校验任务对比新旧库的数据一致性，实时补齐任何差异。</p>
<p><img src="/../../images/MySQL/mysql_partition_scale1.drawio.png" alt="img"></p>
<p>第二阶段是<strong>完成同步并切换读流量</strong>：当确认历史数据已经成功迁移且新库中的写入与旧库始终保持一致后，就可以将所有读操作从旧库切换到新库，从而开始验证新库的查询性能和稳定性。</p>
<p><img src="/../../images/MySQL/mysql_partition_scale2.drawio.png" alt="img"></p>
<p>第三阶段是<strong>停止旧库写入并下线</strong>：在确认旧库不再接收任何新写后，需要等待一段时间以清空剩余连接与缓冲，然后可以安全地关闭或拆除旧库，实现真正的无缝下线。通过这种三阶段流程，在整个扩容过程中既保证了业务的连续性，也维持了数据的一致性和可用性。</p>
<p><img src="/../../images/MySQL/mysql_partition_scale3.drawio.png" alt="img"></p>
<p>尽管在线双写与写时复制在延迟复制、零停机思想上有交集，但它们在层级、触发条件、技术依赖和一致性模型上都有本质区别。在线双写更适合数据库扩容与数据迁移场景；写时复制则是操作系统与存储层面优化内存和文件复制的通用技术。两者均为提升可用性和性能的重要手段，但并非同一机制。</p>
<h2 id="分库分表的问题"><a href="#分库分表的问题" class="headerlink" title="分库分表的问题"></a>分库分表的问题</h2><p>在分库后，单机事务的强一致性优势不再适用，必须引入分布式事务（如两阶段提交或 TCC）来保证跨库的事务完整性；同时，由于数据库实例被拆分，原生的跨库 JOIN 无法直接执行，只能在业务代码中先查询一个库的数据再查询另一个库并进行合并，或通过冗余字段将常用关联信息（如名称）复制到当前表，减少关联请求；另一种思路是利用 binlog 同步等机制将需要跨库关联的数据异构到 Elasticsearch 等专用存储，再由 ES 实现联合查询。</p>
<p>在分表场景下，跨分片的聚合计算（如 COUNT、ORDER BY、GROUP BY）只能通过业务端或中间件对各分表结果进行汇总、排序与分页才能实现；同时，需要在切分前对数据迁移、容量规划及未来扩容的可行性进行充分评估，以避免二次拆分带来的复杂度和风险。更重要的是，表被水平切分后已不能再依赖数据库自身的自增主键机制来保证全局唯一性，常见的替代方案包括：设置不同的自增步长与初始值（例如三张表分别以步长 3、初始值 1、2、3 生成 ID），从而避免冲突；使用 UUID 生成全局唯一主键，但要警惕随机主键可能导致 B-Tree 页分裂、写放大和性能下降；或者采用分布式 ID 生成算法（如 Twitter Snowflake），通过时间戳、节点 ID 及序列号的组合方式高效生成可排序的全局唯一 ID，兼顾性能与一致性。</p>
<p>更多内容可参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1232122">基因法与倒排索引在MySQL分库分表的应用</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1627841">百亿级分片，如何设计基因算法？</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/xGYM0pXAHfaLMpTxBJvLBg">百亿级存储，怎么设计？只是分库分表？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN,en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/2024/11/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/MapReduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/2024/11/22/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/MapReduce/" class="post-title-link" itemprop="url">MapReduce</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-22 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-22T00:00:00-08:00">2024-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-20 17:10:24" itemprop="dateModified" datetime="2025-06-20T17:10:24-07:00">2025-06-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">数据库系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h1 id="编程模型-Programming-Model"><a href="#编程模型-Programming-Model" class="headerlink" title="编程模型 (Programming Model)"></a>编程模型 (Programming Model)</h1><p><strong>输入与输出 (Input and Output):</strong></p>
<ul>
<li>接收一组<strong>输入键&#x2F;值对 (input key&#x2F;value pairs)</strong>。</li>
<li>生成一组<strong>输出键&#x2F;值对 (output key&#x2F;value pairs)</strong>。</li>
</ul>
<p><strong>用户自定义函数 (User-Defined Functions):</strong></p>
<ul>
<li><strong>映射函数 (Map Function)</strong>:<ul>
<li>由用户编写。</li>
<li>处理每个输入键&#x2F;值对。</li>
<li>生成一组<strong>中间键&#x2F;值对 (intermediate key&#x2F;value pairs)</strong>。</li>
</ul>
</li>
<li><strong>归约函数 (Reduce Function)</strong>:<ul>
<li>同样由用户编写。</li>
<li>接收一个中间键 <code>I</code> 及其关联的<strong>值集合 (set of values)</strong>。</li>
<li>合并这些值以产生一个<strong>更小集合 (smaller set)</strong> 的输出值，通常为零个或一个值。</li>
</ul>
</li>
</ul>
<p><strong>中间数据处理 (Intermediate Data Handling):</strong></p>
<ul>
<li><strong>MapReduce 库 (MapReduce library)</strong> 将中间值按其键 (<code>I</code>) 分组，并将它们发送给归约函数。</li>
<li>中间值通过<strong>迭代器 (iterator)</strong> 提供给归约函数，从而能够高效处理因数据量过大而无法全部放入内存的数据集。</li>
</ul>
<p><strong>容错性与可扩展性 (Fault Tolerance and Scalability):</strong></p>
<ul>
<li>通过将任务分解成更小的独立计算单元，MapReduce 确保了即使在大型分布式环境中也能实现可扩展性和容错性。</li>
</ul>
<h1 id="实现-Implementation"><a href="#实现-Implementation" class="headerlink" title="实现 (Implementation)"></a>实现 (Implementation)</h1><p><a target="_blank" rel="noopener" href="https://../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F//mapred_exe_overview.png"><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/mapred_exe_overview.png" alt="img"></a></p>
<p><strong>数据分割与任务分配 (Data Splitting and Task Assignment):</strong></p>
<ul>
<li><strong>输入数据划分</strong>: MapReduce 库自动将输入文件分割成 M 个片段（通常每个片段大小为 16MB 到 64MB，可由用户控制）。</li>
<li><strong>启动程序实例</strong>: 在集群中启动多个程序副本。</li>
<li><strong>角色分配</strong>: 其中一个程序实例被指定为<strong>主节点 (master)</strong>，其余的作为<strong>工作节点 (workers)</strong>。</li>
</ul>
<p><strong>任务调度 (Task Scheduling):</strong></p>
<ul>
<li><strong>主节点的职责</strong>: 主节点负责管理 M 个 map 任务和 R 个 reduce 任务。</li>
<li><strong>任务分配</strong>: 主节点将空闲的工作节点分配给 map 任务或 reduce 任务。</li>
</ul>
<p><strong>Map 阶段 (Map Phase):</strong></p>
<ul>
<li><strong>读取数据</strong>: 被分配 map 任务的工作节点读取对应的输入片段。</li>
<li><strong>处理数据</strong>: 解析出键&#x2F;值对，并将其传递给用户定义的 Map 函数。</li>
<li><strong>生成中间结果</strong>: <strong>Map 函数产生的中间键&#x2F;值对会存储在本地磁盘中。</strong></li>
</ul>
<p><strong>中间数据处理 (Intermediate Data Processing):</strong></p>
<ul>
<li><strong>写入本地磁盘</strong>: **缓存的中间结果会定期写入本地磁盘，<strong>并根据分区函数划分为 R 个区域 (partitioned into R regions)。</strong></li>
<li><strong>通知主节点</strong>: 工作节点将这些中间数据的位置告知主节点，主节点负责将这些信息传递给 reduce 工作节点。</li>
</ul>
<p><strong>Reduce 阶段准备 (Reduce Phase Preparation):</strong></p>
<ul>
<li><strong>读取中间数据</strong>: reduce 工作节点收到主节点的通知后，通过<strong>远程过程调用 (RPC - Remote Procedure Call)</strong> 从 map 工作节点的本地磁盘读取中间数据。</li>
<li><strong>排序数据</strong>: reduce 工作节点将所有中间数据按键排序，以确保相同的键聚集在一起。如果数据量过大，无法全部加载到内存，会采用<strong>外部排序 (external sort)</strong>。</li>
</ul>
<p><strong>Reduce 阶段 (Reduce Phase):</strong></p>
<ul>
<li><strong>执行 Reduce 函数</strong>: reduce 工作节点遍历排序后的中间数据，对于每个唯一的中间键，将键和对应的值列表传递给用户定义的 Reduce 函数。</li>
<li><strong>生成最终输出</strong>: Reduce 函数的输出被追加到该 reduce 分区的最终输出文件中。</li>
</ul>
<p><strong>任务完成与结果返回 (Task Completion and Result Retrieval):</strong></p>
<ul>
<li><strong>任务监控</strong>: 当所有的 map 和 reduce 任务都完成后，主节点会唤醒用户程序。</li>
<li><strong>返回结果</strong>: 此时，用户程序中的 MapReduce 调用返回，用户可以获取 R 个输出文件（每个 reduce 任务对应一个输出文件）。</li>
</ul>
<p><strong>额外说明 (Additional Notes):</strong></p>
<ul>
<li><strong>数据处理链</strong>: 通常用户不需要将这 R 个输出文件合并成一个文件，因为这些文件可以直接作为下一个 MapReduce 调用的输入，或者被能够处理多文件输入的分布式应用程序使用。</li>
<li><strong>流程图参考</strong>: 上图👆用于展示 MapReduce 操作的整体流程（对应上述 7 个步骤）。</li>
</ul>
<h2 id="主节点数据结构-Master-Data-Structure"><a href="#主节点数据结构-Master-Data-Structure" class="headerlink" title="主节点数据结构 (Master Data Structure)"></a>主节点数据结构 (Master Data Structure)</h2><p><strong>任务状态跟踪 (Task State Tracking):</strong></p>
<ul>
<li>对于每个 <strong>map</strong> 和 <strong>reduce 任务</strong>，主节点存储：<ul>
<li><strong>状态</strong>:<ul>
<li><code>idle</code> (空闲): 任务尚未分配。</li>
<li><code>in-progress</code> (执行中): 任务正在被执行。</li>
<li><code>completed</code> (已完成): 任务执行完毕。</li>
</ul>
</li>
<li><strong>工作节点标识 (Worker Identity)</strong>: 处理该任务的工作机器（针对非空闲任务）。</li>
</ul>
</li>
</ul>
<p><strong>中间数据管理 (Intermediate Data Management):</strong></p>
<ul>
<li>主节点充当将中间数据从 map 任务传递到 reduce 任务的<strong>管道 (conduit)</strong>。</li>
<li>对于每个已完成的 map 任务：<ul>
<li>它记录所生成的 <code>R</code> 个中间文件区域的<strong>位置</strong> 和<strong>大小</strong>。</li>
<li>这些数据对于 reduce 任务从相应的 map 工作节点获取中间结果至关重要。</li>
</ul>
</li>
</ul>
<p><strong>动态更新 (Dynamic Updates):</strong></p>
<ul>
<li>随着 map 任务完成，主节点持续更新其记录的中间文件位置和大小。</li>
<li>这些更新会增量式地推送给当前正在执行中的 reduce 工作节点。</li>
</ul>
<h2 id="容错机制-Fault-Tolerance"><a href="#容错机制-Fault-Tolerance" class="headerlink" title="容错机制 (Fault Tolerance)"></a>容错机制 (Fault Tolerance)</h2><p><strong>工作节点故障 (Worker Failure)</strong></p>
<ul>
<li><strong>故障检测 (Failure Detection)</strong>:<ul>
<li><strong>主节点</strong>定期向<strong>每个工作节点</strong>发送 <strong>ping</strong>。</li>
<li>如果工作节点在特定时间窗口内未响应，主节点将其标记为<strong>故障</strong>。</li>
</ul>
</li>
<li><strong>任务重新调度 (Task Rescheduling)</strong>:<ul>
<li><strong>Map 任务 (Map Tasks)</strong>:<ul>
<li><strong>已完成的 Map 任务 (Completed Map Tasks)</strong>:<ul>
<li>如果故障工作节点已完成 map 任务，其输出将变得不可访问（存储在故障机器的本地磁盘上）。</li>
<li>这些任务被重置为<strong>空闲状态 (idle state)</strong> 并在其他工作节点上重新执行。</li>
</ul>
</li>
<li><strong>执行中的 Map 任务 (In-Progress Map Tasks)</strong>:<ul>
<li>类似地，执行中的任务被标记为空闲并重新分配给可用的工作节点。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Reduce 任务 (Reduce Tasks)</strong>:<ul>
<li><strong>已完成的 Reduce 任务 (Completed Reduce Tasks)</strong>:<ul>
<li>这些任务<strong>不需要</strong>重新执行，因为它们的输出存储在<strong>全局文件系统 (global file system)</strong> 中，即使发生故障也仍然可访问。</li>
</ul>
</li>
<li><strong>执行中的 Reduce 任务 (In-Progress Reduce Tasks)</strong>:<ul>
<li>如果某些 reduce 工作节点尚未读取中间数据，它们会从新的（重新执行的 map 任务的）结果中读取数据。</li>
</ul>
</li>
</ul>
</li>
<li><strong>数据协调 (Data Coordination)</strong>:<ul>
<li>当 map 任务在新的工作节点上重新执行时：<ul>
<li><strong>通知 (Notification)</strong>: 所有 reduce 工作节点会被告知该重新执行。</li>
<li><strong>数据重定向 (Data Redirection)</strong>: 尚未从故障工作节点获取中间数据的 reduce 工作节点将改为从新的工作节点获取数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>主节点故障 (Master Failure)</strong></p>
<ul>
<li>可以很方便地让主节点定期将上述主节点数据结构写入<strong>检查点 (checkpoints)</strong>。如果主节点任务终止，可以从最后一个检查点状态启动一个新的副本。</li>
<li>然而，考虑到只有一个主节点，其故障的可能性很低；<strong>因此我们当前的实现在主节点故障时会中止 MapReduce 计算。</strong> 客户端可以检测到此情况，并在需要时重试 MapReduce 操作。</li>
</ul>
<h2 id="数据本地化-Locality"><a href="#数据本地化-Locality" class="headerlink" title="数据本地化 (Locality)"></a>数据本地化 (Locality)</h2><ul>
<li><strong>存储设计</strong>: 数据存储在 <strong>Google 文件系统 (GFS - Google File System)</strong> 中。GFS 将每个文件分割为 64 MB 的块 (blocks)，并在不同的机器上保存多个副本（通常是 3 个）。</li>
<li><strong>任务调度优先级</strong>:<ul>
<li><strong>优先本地化调度</strong>: 主节点优先将 map 任务分配给<strong>包含对应数据块副本的同一台机器</strong>上的工作节点。</li>
<li><strong>次优调度</strong>: 如果本地调度不可行（例如，拥有数据块副本的工作节点繁忙），主节点将任务分配给靠近副本的机器，例如同一机架 (rack) 或数据中心 (data center) 内的机器。</li>
</ul>
</li>
<li><strong>实际效果</strong>: 在运行大型 MapReduce 操作时，大部分输入数据会从本地磁盘读取。因为数据本地化，减少了跨网络传输的数据量，从而节省网络带宽。</li>
</ul>
<h2 id="任务粒度-Task-Granularity"><a href="#任务粒度-Task-Granularity" class="headerlink" title="任务粒度 (Task Granularity)"></a>任务粒度 (Task Granularity)</h2><ol>
<li><strong>Map 和 Reduce 阶段的划分</strong><ul>
<li><strong>任务数量 (M 和 R)</strong>: Map 阶段被划分为 M 个任务。Reduce 阶段被划分为 R 个任务。</li>
<li><strong>划分原则</strong>: 理想情况下，M 和 R 的数量应该<strong>远大于</strong>工作节点的数量（即机器的数量）。</li>
</ul>
</li>
<li><strong>多任务划分的好处</strong><ul>
<li><strong>动态负载均衡</strong>: 每个工作节点可执行多个任务，这样可以动态调整任务分配，避免某些节点过载或闲置。</li>
<li><strong>故障恢复加速</strong>: 如果某个工作节点失败，其已完成的多个任务可以分散到其他节点重新执行，恢复速度更快。</li>
</ul>
</li>
<li><strong>任务划分的实际限制</strong><ul>
<li><strong>调度开销</strong>: 主节点需要进行 O(M + R) 次调度决策，且需要存储 O(M × R) 的状态信息。虽然每对 map&#x2F;reduce 任务对仅占用约 1 字节内存，但过多任务会增加内存需求和调度复杂性。</li>
<li><strong>输出文件限制</strong>: R 的大小往往受到用户需求限制，因为每个 reduce 任务会生成一个独立的输出文件。输出文件过多会导致文件管理复杂。</li>
</ul>
</li>
<li><strong>实际任务大小选择</strong><ul>
<li><strong>Map 阶段</strong>: 每个 map 任务通常处理 <strong>16 MB 到 64 MB</strong> 的输入数据。这样的任务大小可以充分利用<strong>数据本地化优化</strong>（即尽量从本地磁盘读取数据）。</li>
<li><strong>Reduce 阶段</strong>: R 通常是工作节点数量的几倍，以充分利用并行能力。在一个典型的大规模 MapReduce 计算中：<ul>
<li>M &#x3D; 200,000（Map 阶段任务数）。</li>
<li>R &#x3D; 5,000（Reduce 阶段任务数）。</li>
<li>工作节点 &#x3D; 2,000（机器数量）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="备份任务-Backup-Tasks"><a href="#备份任务-Backup-Tasks" class="headerlink" title="备份任务 (Backup Tasks)"></a>备份任务 (Backup Tasks)</h2><ol>
<li><strong>什么是拖后腿的任务（Straggler Tasks）？</strong><ul>
<li><strong>定义</strong>: 拖后腿任务指的是 MapReduce 作业中运行速度<strong>远慢于</strong>其他任务的任务（map 或 reduce），从而<strong>延迟整个作业的完成</strong>。</li>
</ul>
</li>
<li><strong>解决方法</strong>:<ul>
<li><strong>备份任务机制</strong>: 当 MapReduce 计算接近完成时，主节点会为<strong>未完成的任务</strong>安排<strong>备份执行 (Backup Executions)</strong>。同一任务的多个副本在不同的工作节点上<strong>同时运行</strong>。只要其中一个副本完成，任务即被标记为完成。</li>
<li><strong>资源开销</strong>: 调整后的机制只增加少量（通常是几个百分点）的计算资源使用。通过备份执行，能够<strong>显著缩短</strong>总执行时间。</li>
</ul>
</li>
</ol>
<h1 id="优化与增强-Refinement"><a href="#优化与增强-Refinement" class="headerlink" title="优化与增强 (Refinement)"></a>优化与增强 (Refinement)</h1><p><strong>分区函数 (Partitioning Function)</strong></p>
<ol>
<li><strong>Reduce 任务与分区</strong><ul>
<li>用户通过设置 <strong>R</strong> 来指定需要的 reduce 任务数或输出文件数。</li>
<li>数据在这些 reduce 任务之间分区，分区方式取决于<strong>分区函数</strong>。</li>
</ul>
</li>
<li><strong>默认分区方式</strong><ul>
<li>默认使用<strong>哈希函数</strong>。</li>
<li><strong>分区规则</strong>: <code>hash(key) mod R</code>。</li>
<li><strong>优势</strong>: 通常能实现较为<strong>均衡的分区</strong>（即数据均匀分布到不同 reduce 任务中）。</li>
</ul>
</li>
<li><strong>自定义分区方式</strong><ul>
<li>有时默认的哈希分区不满足实际需求，需要根据特定逻辑对数据进行分区。例如：数据的键是 URL，用户希望所有来自<strong>同一主机 (host)</strong> 的条目存储在同一个输出文件中。</li>
<li><strong>解决方案</strong>: 用户可以定义自己的分区函数，例如：<code>hash(Hostname(urlkey)) mod R</code>：根据 URL 的<strong>主机名 (hostname)</strong> 分区。这样，来自同一主机的所有条目会被分配到<strong>相同的 reduce 任务</strong>中。</li>
</ul>
</li>
</ol>
<p><strong>排序保证 (Ordering Guarantees)</strong></p>
<ol>
<li><strong>排序保证</strong><ul>
<li>在 MapReduce 的<strong>每个分区内</strong>，中间的键&#x2F;值对（key&#x2F;value pairs）会按照<strong>键的递增顺序</strong> 进行处理。</li>
<li><strong>目标</strong>: 确保每个分区的输出文件是<strong>有序的</strong>。</li>
</ul>
</li>
<li><strong>排序的作用</strong><ul>
<li><strong>生成有序输出文件</strong>: 每个 reduce 任务生成的输出文件是按键排序的，直接支持有序数据的存储。</li>
<li><strong>支持高效随机访问</strong>: 有序数据便于通过键值实现高效的随机访问。</li>
<li><strong>用户便利</strong>: 用户使用这些输出文件时，通常不需要额外排序。</li>
</ul>
</li>
</ol>
<p><strong>合并函数 (Combiner Function)</strong></p>
<ol>
<li><strong>问题背景</strong><ul>
<li>在某些情况下，中间键<strong>重复率较高</strong>，每个 map 任务可能会生成大量重复的中间键记录。<strong>示例</strong>: 在单词计数任务中（例如 <code>&lt;the, 1&gt;</code>），常见单词（如 “the”）会频繁出现。</li>
<li><strong>结果</strong>: 这些重复记录需要通过网络传输到同一个 reduce 任务，增加了网络负载。</li>
</ul>
</li>
<li><strong>Combiner 函数的解决方案</strong><ul>
<li><strong>定义</strong>: Combiner 是一个<strong>可选的、局部的聚合函数</strong>，<strong>用于在 map 任务所在机器上对中间数据进行部分合并。</strong></li>
<li><strong>工作原理</strong>:<ul>
<li><strong>执行位置</strong>: Combiner 在 map 任务的机器上运行。</li>
<li><strong>功能</strong>: 对<strong>重复键</strong>的中间结果进行<strong>局部汇总</strong>，减少需要传输的数据量。</li>
<li><strong>例如</strong>: 将 <code>&lt;the, 1&gt;</code>、<code>&lt;the, 1&gt;</code>、<code>&lt;the, 1&gt;</code> 合并为 <code>&lt;the, 3&gt;</code>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Combiner 和 Reduce 的区别</strong><ul>
<li><strong>相同点</strong>: 通常，Combiner 的代码与 Reduce 函数的代码<strong>相同</strong>。都用于对数据进行<strong>聚合处理</strong>。</li>
<li><strong>不同点</strong>:<ul>
<li><strong>Combiner</strong>: 输出的是<strong>中间结果</strong>，数据会<strong>继续传递</strong>给 Reduce 任务。</li>
<li><strong>Reduce</strong>: 输出的是<strong>最终结果</strong>，数据写入最终的输出文件。</li>
</ul>
</li>
</ul>
</li>
<li><strong>优化效果</strong><ul>
<li><strong>减少网络传输量</strong>: 通过提前合并数据，Combiner 显著减少了从 map 任务到 reduce 任务的数据量。例如，不传输 1000 条 <code>&lt;the, 1&gt;</code>，而是只传输 1 条 <code>&lt;the, 1000&gt;</code>。</li>
<li><strong>提升性能</strong>: 对于重复率高的任务，Combiner 能显著加快 MapReduce 操作的速度。</li>
</ul>
</li>
</ol>
<p><strong>输入与输出类型 (Input and Output Types)</strong></p>
<ol>
<li><strong>输入数据格式的支持</strong><ul>
<li><strong>预定义格式</strong>:<ul>
<li><strong>文本模式</strong>: 每行数据被视为一个键&#x2F;值对。<ul>
<li>键：文件中该行的<strong>偏移量</strong>。</li>
<li>值：该行的<strong>内容</strong>。</li>
</ul>
</li>
<li><strong>排序键&#x2F;值对模式 (sorted key&#x2F;value mode)</strong>: 存储的键&#x2F;值对按键排序，便于按范围处理。</li>
</ul>
</li>
<li><strong>自动分割范围</strong>: 每种输入格式都有<strong>分割机制</strong>，可将输入数据划分为适合 map 任务处理的范围。例如，文本模式会确保分割发生在<strong>行边界</strong>，而不是行中间，保证数据的完整性。</li>
<li><strong>用户自定义格式</strong>: 用户可以通过实现简单的<strong>读取接口 (reader interface)</strong>，支持新的输入类型。<ul>
<li><strong>非文件输入</strong>: 数据可以来自其他来源，如数据库或内存中的数据结构，而不一定是文件。</li>
</ul>
</li>
</ul>
</li>
<li><strong>输出数据格式的支持</strong><ul>
<li>类似输入格式，MapReduce 也支持多种输出格式：<ul>
<li><strong>预定义格式</strong>: 提供了一些常用的输出格式。</li>
<li><strong>自定义格式</strong>: 用户可以通过实现新的接口定义输出数据格式。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>跳过错误记录 (Skipping Bad Records)</strong></p>
<ol>
<li><strong>问题背景</strong><ul>
<li><strong>用户代码缺陷</strong>: Map 或 Reduce 函数中可能存在错误（如某些记录引发崩溃）。</li>
<li><strong>确定性崩溃</strong>: 对特定记录，每次处理都会发生崩溃。</li>
<li><strong>问题影响</strong>: 这类错误可能<strong>阻止整个 MapReduce 操作完成</strong>。</li>
<li><strong>无法修复的情况</strong>: 错误可能在<strong>第三方库</strong>中，用户无法访问源代码。</li>
</ul>
</li>
<li><strong>MapReduce 提供的解决方案</strong><ul>
<li><strong>跳过问题记录</strong>: MapReduce 允许系统检测引发崩溃的记录，并跳过这些记录以继续操作。</li>
<li><strong>实现机制</strong>:<ul>
<li><strong>信号处理</strong>: 每个工作节点安装<strong>信号处理器</strong>，捕获<strong>段错误 (segmentation violations)</strong> 和<strong>总线错误 (bus errors)</strong>。</li>
<li><strong>记录错误序号</strong>: 在调用用户的 Map 或 Reduce 函数之前，系统将参数的<strong>序列号 (sequence number)</strong> 存储在全局变量中。</li>
<li><strong>发送错误报告</strong>: 如果用户代码触发错误，信号处理器会发送一个 <strong>“最后的喘息” (last gasp)</strong> UDP 数据包，包含引发错误的记录序号，通知主节点。</li>
<li><strong>主节点决策</strong>: 如果一条记录多次导致失败，主节点指示在下次重试该任务时<strong>跳过 (skip)</strong> 这条记录。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>本地执行 (Local Execution)</strong></p>
<ol>
<li><strong>分布式调试的挑战</strong><ul>
<li><strong>复杂性</strong>: Map 和 Reduce 函数的实际计算是在分布式系统上完成，涉及数千台机器。主节点动态分配任务，调试难以直接定位问题。</li>
<li><strong>常见问题</strong>: 分布式环境下的日志、任务状态和数据流使得问题排查更加困难。</li>
</ul>
</li>
<li><strong>本地执行模式的设计</strong><ul>
<li><strong>功能</strong>: MapReduce 提供了一种<strong>本地执行的替代实现</strong>，在<strong>单台机器</strong>上<strong>顺序执行</strong>整个 MapReduce 操作。</li>
<li><strong>特点</strong>: 所有任务按顺序运行，无需分布式调度。用户可以<strong>限制计算范围</strong>，仅调试特定的 map 任务。</li>
</ul>
</li>
</ol>
<p><strong>计数器 (Counter)</strong></p>
<ul>
<li>计数器用于跟踪 MapReduce 操作期间特定事件的发生次数，例如：<ul>
<li>用户定义的<strong>自定义事件</strong>（例如，单词计数、检测特定模式）。</li>
<li><strong>系统定义的指标</strong>，如处理的输入&#x2F;输出键值对数量。</li>
</ul>
</li>
</ul>
<p><strong>计数器工作原理 (How Counters Work)</strong></p>
<ul>
<li><strong>传播到主节点 (Propagation to the Master)</strong>: 来自各个工作节点的计数器值通过 <strong>ping 响应</strong> 发送到<strong>主节点</strong>。</li>
<li><strong>聚合 (Aggregation)</strong>:<ul>
<li>主节点聚合所有已完成任务的计数器值。</li>
<li>它通过忽略重复的任务执行（例如，由于重新执行或备份任务）来确保<strong>没有重复计数</strong>。</li>
</ul>
</li>
</ul>
<p><strong>监控与报告 (Monitoring and Reporting)</strong></p>
<ul>
<li><strong>实时监控 (Real-Time Monitoring)</strong>: 当前的计数器值显示在<strong>主节点状态页面</strong> 上，允许用户观察计算的进度。</li>
<li><strong>最终报告 (Final Reporting)</strong>: 当 MapReduce 作业完成时，聚合后的计数器值返回给用户程序。</li>
</ul>
<h1 id="问题-Questions"><a href="#问题-Questions" class="headerlink" title="问题 (Questions)"></a>问题 (Questions)</h1><p><strong>假设 M&#x3D;10 且 R&#x3D;20，映射器 (mappers) 产生的文件总数是多少？</strong></p>
<blockquote>
<p>总文件数 &#x3D; M × R &#x3D; 10 × 20 &#x3D; 200</p>
</blockquote>
<p><strong>为什么 MapReduce 将 Reduce 的输出存储在 Google 文件系统 (GFS) 中？</strong></p>
<blockquote>
<ul>
<li><strong>高可用性 (High Availability)</strong>: GFS 通过在多个机器上<strong>复制数据 (replicating data)</strong> 提供容错能力。这确保了即使一台机器故障，输出也不会丢失。</li>
<li><strong>可扩展性 (Scalability)</strong>: GFS 专为处理大规模数据存储而设计，适用于 MapReduce 作业产生的大量输出。</li>
</ul>
</blockquote>
<p><strong>拖后腿任务 (straggler) 的目的是什么？</strong></p>
<blockquote>
<ul>
<li><strong>“拖后腿任务 (Straggler)” 指的是运行缓慢的任务</strong>，通常是 map 或 reduce 任务，它们会<strong>显著延迟</strong> MapReduce 作业的完成。</li>
<li><strong>解决方法</strong>:<ul>
<li><strong>备份执行 (Backup Execution)</strong>: 主节点在其它可用工作节点上为拖后腿任务安排备份执行。</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>判断对错：可以在没有模式 (schema) 的情况下，对 CSV 数据文件使用 SQL++。</strong></p>
<blockquote>
<p><strong>正确 (True)</strong>: SQL++ 可以操作半结构化数据，包括 CSV 文件，而<strong>不需要</strong>预定义的模式。</p>
</blockquote>
<p><strong>在 SQL++ 中，pivot 和 unpivot 有什么区别？</strong></p>
<blockquote>
<p><strong>Pivot (透视)</strong>:</p>
<ul>
<li><strong>目的</strong>: 将<strong>行 (rows)</strong> 转换为<strong>属性 (attributes) &#x2F; 列 (columns)</strong>。</li>
<li><strong>示例</strong>:<ul>
<li>输入: <code>[ &#123; &quot;symbol&quot;: &quot;amzn&quot;, &quot;price&quot;: 1900 &#125;, &#123; &quot;symbol&quot;: &quot;goog&quot;, &quot;price&quot;: 1120 &#125;, &#123; &quot;symbol&quot;: &quot;fb&quot;, &quot;price&quot;: 180 &#125; ]</code></li>
<li>查询: <code>PIVOT sp.price AT sp.symbol FROM today_stock_prices sp;</code></li>
<li>输出: <code>&#123; &quot;amzn&quot;: 1900, &quot;goog&quot;: 1120, &quot;fb&quot;: 180 &#125;</code></li>
</ul>
</li>
</ul>
<p><strong>Unpivot (逆透视)</strong>:</p>
<ul>
<li><strong>目的</strong>: 将<strong>属性 (attributes) &#x2F; 列 (columns)</strong> 转换为<strong>行 (rows)</strong>。</li>
<li><strong>示例</strong>:<ul>
<li>输入: <code>&#123; &quot;date&quot;: &quot;4/1/2019&quot;, &quot;amzn&quot;: 1900, &quot;goog&quot;: 1120, &quot;fb&quot;: 180 &#125;</code></li>
<li>查询: <code>UNPIVOT c AS price AT sym FROM closing_prices c WHERE sym != &#39;date&#39;;</code></li>
<li>输出: <code>[ &#123; &quot;date&quot;: &quot;4/1/2019&quot;, &quot;symbol&quot;: &quot;amzn&quot;, &quot;price&quot;: 1900 &#125;, &#123; &quot;date&quot;: &quot;4/1/2019&quot;, &quot;symbol&quot;: &quot;goog&quot;, &quot;price&quot;: 1120 &#125;, &#123; &quot;date&quot;: &quot;4/1/2019&quot;, &quot;symbol&quot;: &quot;fb&quot;, &quot;price&quot;: 180 &#125; ]</code></li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>使用 BG ，可以通过其 SoAR (Satisfaction of Agreement Ratio) 来总结数据存储的性能。计算数据存储 SoAR 的 BG 输入是什么？</strong></p>
<blockquote>
<p><strong>1. SLA 规范 (SLA Specifications)</strong></p>
<p>服务等级协议 (SLA) 定义了计算 SoAR 的条件。SLA 包括：</p>
<ul>
<li><strong>α</strong>: 必须观察到响应时间小于或等于 β 的请求百分比（例如，95%）。</li>
<li><strong>β</strong>: 最大可接受响应时间（例如，100 毫秒）。</li>
<li><strong>τ</strong>: 观察到不可预测（过时或不一致）数据的请求的最大允许百分比（例如，0.01%）。</li>
<li><strong>Δ</strong>: SLA 必须被满足的持续时间（例如，10 分钟）。</li>
</ul>
<p><strong>2. 数据库配置 (Database Configuration)</strong></p>
<p>关于被测数据存储的详细信息：</p>
<ul>
<li><strong>逻辑模式 (Logical Schema)</strong>: 数据存储使用的数据模型（例如，关系模式、NoSQL 的类 JSON 模式）。</li>
<li><strong>物理设置 (Physical Setup)</strong>: 硬件配置，包括：<ul>
<li>节点数量。</li>
<li>存储和内存资源。</li>
<li>网络能力。</li>
</ul>
</li>
<li><strong>数据量大小 (Population Size)</strong>:<ul>
<li><strong>M</strong>: 数据库中的成员数量。</li>
<li><strong>ϕ</strong>: 每个成员的关注者&#x2F;朋友数量。</li>
<li><strong>ρ</strong>: 每个成员的资源数量。</li>
</ul>
</li>
</ul>
<p><strong>3. 工作负载参数 (Workload Parameters)</strong></p>
<p>工作负载指定了 BG 将模拟的操作的性质和强度：</p>
<ul>
<li><strong>操作混合比例 (Mix of Actions)</strong>:<ul>
<li>社交网络操作的类型（例如，查看个人资料、列出朋友、查看好友请求）。</li>
<li>每种操作类型的百分比（读密集型、写密集型或混合工作负载）。</li>
</ul>
</li>
<li><strong>思考时间 (ϵ - Think Time)</strong>: 单个线程执行连续操作之间的延迟。</li>
<li><strong>到达间隔时间 (ψ - Inter-Arrival Time)</strong>: 新用户会话之间的延迟。</li>
</ul>
<p><strong>4. 环境参数 (Environmental Parameters)</strong></p>
<p>关于 BG 如何生成和管理工作负载的详细信息：</p>
<ul>
<li><strong>BGClients 数量 (N)</strong>: 负责生成请求的实例数。</li>
<li><strong>线程数量 (T)</strong>: 并发级别（每个 BGClient 的线程数）。</li>
<li><strong>D-Zipfian 分布参数 (θ)</strong>: 定义访问模式（例如，热门数据与冷门数据的访问频率）。</li>
</ul>
</blockquote>
<p><strong>考虑键值对优先级 (priority) 的以下二进制表示：00101001。其精度为 4 的 CAMP 舍入 (CAMP rounding) 结果是什么？</strong></p>
<blockquote>
<p>00101000<br><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/bg_bm_rounding.png" alt="img"></p>
</blockquote>
<p><strong>什么是惊群效应 (thundering herd)？IQ 框架如何防止它导致持久化数据存储成为瓶颈？</strong></p>
<blockquote>
<p><strong>惊群效应问题 (Thundering Herd Problem)</strong>:</p>
<ul>
<li>当一个键值对在键值存储 (KVS) 中<strong>未找到</strong>（发生 <strong>KVS 未命中 (KVS miss)</strong>）时，多个读取会话可能会<strong>同时</strong>查询关系数据库管理系统 (RDBMS) 以获取该值。</li>
<li>这可能在<strong>高并发</strong>情况下使 RDBMS <strong>过载</strong>并导致性能下降。</li>
</ul>
<p><strong>IQ 框架的解决方案</strong>:</p>
<ul>
<li>当<strong>第一个</strong>读取会话遇到 KVS 未命中时，它会为该键请求一个 <strong>I 租约 (I lease)</strong>。</li>
<li>一旦 I 租约被授予，KVS 会<strong>阻止</strong>其他读取会话为同一个键查询 RDBMS。</li>
<li>所有其他读取会话必须 <strong>“回退 (back off)”</strong> 并等待持有 I 租约的会话将值更新到 KVS 中。</li>
</ul>
<blockquote>
<p>(补充解释) 惊群效应发生在特定键经历<strong>大量读写活动</strong>时。</p>
<ul>
<li>写入操作<strong>重复地使缓存失效 (invalidate the cache)</strong>。</li>
<li>所有读取操作都<strong>被迫查询数据库</strong>。</li>
</ul>
<p><strong>I 租约解决了这个问题</strong>：</p>
<ul>
<li>对特定键的<strong>第一次读取</strong>被授予 I 租约。</li>
<li>所有其他读取观察到未命中并<strong>回退</strong>。</li>
<li>持有 I 租约的读取查询 RDBMS，计算缺失的值，并将该值<strong>填充 (populate)</strong> 到缓存中。</li>
<li>所有其他读取随后会<strong>观察到缓存命中 (cache hit)</strong>。</li>
</ul>
</blockquote>
</blockquote>
<p><strong>参考</strong>: <a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf">https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/mapreduce-osdi04.pdf</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN,en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/MySQL/2024/11/20/MySQL/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/MySQL/2024/11/20/MySQL/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/" class="post-title-link" itemprop="url">主从复制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-20T00:00:00-08:00">2024-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-22 14:31:01" itemprop="dateModified" datetime="2025-06-22T14:31:01-07:00">2025-06-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><p>在基于 Binlog 的异步复制模式中，主库将所有 DDL 与 DML 操作写入二进制日志，并在本地完成事务提交后立即返回，无需等待从库确认，从而实现松散耦合的复制流程。随后，从库的 <strong>IO 线程</strong>会与主库保持长连接，不断读取新生成的 binlog 事件并将它们写入本地的 <strong>Relay Log</strong>。接着，从库的 <strong>SQL 线程</strong>会顺序读取 Relay Log 中的事件，并在从库上重做这些 DDL 与 DML，以达到数据同步的目的。</p>
<p><img src="/../../images/MySQL/mysql_replic_ms.drawio.png" alt="img"></p>
<p>MySQL 支持一主多从复制拓扑，且从库本身也可以配置为其他从库的源库，实现链式复制。这种异步复制模式允许在主库出现故障时，通过提升任一从库为新的主库来快速切换并恢复服务，极大增强了系统的高可用性。同时，通过将写操作集中到主库、将读操作分散到从库，也减轻了主库的负载，并可在从库上执行备份任务，避免对主库性能产生影响。由于主库无需等待从库完成写入，可获得更高的写入吞吐量，但也可能引入复制延迟问题，需要结合监控指标加以管理。为进一步降低从库的应用延迟，可使用并行复制功能，让 SQL 线程并发地执行多个复制通道中的事件。总体而言，基于 Binlog 的异步复制以其配置简单、可扩展性强和高可用性好等特点，成为 MySQL 最常用的主从复制方案。</p>
<p>在主从复制中，<strong>Relay Log</strong> 起到四大关键作用：</p>
<p>首先，它充当从库的缓冲区——IO 线程不断地将主库的二进制日志拉取并写入本地的 Relay Log，即使 SQL 线程处理变更较慢，也不会影响向主库的读取，从而有效降低延迟；</p>
<p>其次，Relay Log 支持异步处理——IO 线程与 SQL 线程分离，前者专注拉取日志，后者专注重放语句，两者互不阻塞，大幅提升同步的并发能力；</p>
<p>第三，它增强了数据可靠性——日志落盘后即便网络波动或从库重启，SQL 线程也能从已持久化的 Relay Log 继续执行，无需重新拉取；</p>
<p>最后，在链式复制场景中，从库的 Relay Log 同样可以对下游从库提供日志源，成为二进制日志传递链上的一环。这样，Relay Log 不仅保证了数据的连续、高效复制，还提升了系统的容错与可扩展性。</p>
<h2 id="同步延迟的原因"><a href="#同步延迟的原因" class="headerlink" title="同步延迟的原因"></a>同步延迟的原因</h2><p>主从同步延迟通常是因为从库的复制流程存在瓶颈：主库可以同时接收大量并发写请求，但从库只有一个 IO 线程负责拉取 binlog、一个 SQL 线程负责执行，如果某条 SQL 在从库上执行耗时较长或因锁等待而阻塞，就会造成 binlog 在从库端堆积，进而引起读写不一致。为缓解这一问题，一方面可以在写操作后立即把紧接着的读操作路由到主库，以确保及时读取最新数据；另一方面也可在读从库失败时自动再去主库重试二次读取，这种方式改动最小，但会增加主库的读负载；此外，还可以将关键业务（如注册、登录）的所有读写都定向主库处理，而对一致性要求较低的查询（如用户资料展示）继续采用读写分离，从而在保证关键路径数据正确性的同时，将大部分查询压力分散到从库。</p>
<h2 id="同步模式"><a href="#同步模式" class="headerlink" title="同步模式"></a>同步模式</h2><h3 id="异步复制"><a href="#异步复制" class="headerlink" title="异步复制"></a>异步复制</h3><p>异步复制（Asynchronous Replication）是 MySQL 最基础也是最常用的复制方式，其中主库在本地提交事务并写入二进制日志后即可立即返回客户端，从库的 IO 线程随后异步地拉取这些 binlog 并将其写入 Relay Log，最后由 SQL 线程在从库上执行重放，从而完成数据同步。由于主库无需等待从库确认即完成提交，异步复制能够获得最高的写入吞吐量，但会产生一定的复制延迟，若主库故障，尚未同步的事务可能丢失。</p>
<h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><p>半同步复制（Semisynchronous Replication）介于异步与全同步之间，当主库提交一个事务时，会阻塞等待至少一个从库的确认（即从库已将该事务事件接收并写入 Relay Log，但不必执行完毕）后才向客户端返回，从而保证提交成功的事务至少存在于主库和一个从库上。相比纯异步复制，半同步复制在保证可用性的同时，显著提升了数据安全性；但因需等待确认，写延迟会略高于异步模式，尤其在网络或从库性能较差时更为明显。</p>
<h3 id="全同步复制（组复制）"><a href="#全同步复制（组复制）" class="headerlink" title="全同步复制（组复制）"></a>全同步复制（组复制）</h3><p>全同步复制通常由 MySQL Group Replication 或 NDB Cluster 实现，要求主库在提交时，所有或一定多数的副本必须完成提交确认后才继续执行，从而实现真正的强同步。该模式在保证各节点数据实时一致性方面最强，但也带来最高的写延迟和最复杂的部署需求，通常用于对一致性和故障切换要求极高的场景。</p>
<p><strong>百万千万级大表如何添加字段？</strong></p>
<p>在面对上千万行的大表时，直接执行 <code>ALTER TABLE … ADD COLUMN</code> 往往会长时间锁表，影响线上业务；常见的无停机扩容方案包括：</p>
<p>一是在新库&#x2F;新表中先创建完整的表结构并添加字段，然后通过分批次或全量迁移程序将旧表数据复制过去，最后再原子化地用新表替换旧表（此法简洁但需要额外迁移逻辑）；</p>
<p>二是借助 Percona 的 pt-online-schema-change 或 GitHub 的 gh-ost 等在线变更工具，它们会在后台创建影子表、实时捕获并同步写入，通过触发器或 binlog 流将增量写入合并到新表，待数据迁移完成后再用重命名操作切换，无需停机且复制过程中表仍可读写；</p>
<p>三是针对极高并发的热表，可先在从库执行字段添加操作，待从库完成同步并切换读写角色后，再依次在其他节点上部署新字段，最大程度上降低主库负载和用户感知的停机风险。</p>
<p><strong>当 MySQL 表的数据量增长过快，导致查询性能下降时，你会采取哪些措施来优化表的设计或查询？</strong></p>
<p>当表数据量激增导致单表查询与写入性能下降时，可采取以下优化措施：</p>
<p>首先，通过水平分表将数据按用户 ID 或时间等分片键拆分到多张子表或多库中，以减少单表大小、降低锁竞争并分散 I&#x2F;O 压力；</p>
<p>其次，合理设计索引，包括对经常用于过滤的单个字段创建单列索引、对多字段组合查询创建复合索引，以及使用覆盖索引来避免回表，但切忌在索引字段上使用函数或表达式以免导致索引失效；</p>
<p>其三，可在应用层或独立缓存层（如 Redis）缓存热点数据或热点查询结果，显著减少数据库访问次数并缓解压力；</p>
<p>第四，定期将历史或冷数据归档到独立的存档表、数据仓库或专用归档系统中，保持主表的数据量在可控范围内，从而提升主表的查询效率；</p>
<p>最后，当单机 MySQL 无法再满足性能与扩展需求时，可考虑迁移到分布式数据库（如 TiDB、PolarDB），利用其水平可扩展架构和分布式事务能力，实现更大规模的数据存储与高并发访问。</p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>在主从复制架构中，可以将数据库服务器组织成一主一从或一主多从的集群模式：所有写操作（INSERT、UPDATE、DELETE 等）都集中发送到主库，以保证强一致性；主库会将数据变更实时同步到一个或多个从库，而从库则专注于处理只读查询，提供最终一致性的读服务。业务服务器根据操作类型，将写请求路由到主库，将读请求路由到从库，从而在不影响写入性能和一致性的前提下，大幅提升整体系统的读扩展能力和稳定性。</p>
<p>这样做有几个好处：</p>
<p>第一，写入流量只作用于主库，从库则专注于处理查询请求，可显著减轻单台数据库的压力；</p>
<p>第二，通过增加从库数量，可以水平扩展读能力，提升整体系统的并发查询性能；</p>
<p>第三，即使在从库进行备份或维护时，也能保证主库持续提供写入服务，增强了系统的可用性和抗故障能力。</p>
<p>需要注意的是，从库与主库之间存在微小的复制延迟，因此对于对实时性要求极高的查询，应优先访问主库或使用读写路由策略进行合理调度；同时，还要考虑事务隔离和一致性需求，确保读写分离不会引入数据不一致风险。通过合理配置负载均衡和故障切换机制，读写分离能够在保证数据安全与一致性的前提下，大幅提升数据库集群的性能和稳定性。</p>
<p><img src="/../../images/MySQL/mysql_replic_re_decoup.drawio.png" alt="img"></p>
<p>在程序层面，实现读写分离通常有两种方式：</p>
<p>一种是在业务代码中抽象出一个数据访问层（或“中间层”），由这一层统一管理主从库的连接和路由逻辑，业务逻辑只需调用该层提供的接口即可完成读写分离，如下图；</p>
<p><img src="/../../images/MySQL/mysql_replic_mid.drawio.png" alt="img"></p>
<p>另一种是通过独立部署的中间件系统来承担这项工作，它对外提供与数据库协议兼容的接口，自动将写请求路由到主库、读请求分发到从库，业务服务器无需关心具体的分库路由和连接管理。这样既能保持程序的清晰简洁，又能在中间件层面灵活扩展和运维读写分离的能力。具体结构如下图：</p>
<p><img src="/../../images/MySQL/mysql_replic_mycat.drawio.png" alt="img"></p>
<p>如果要是用 MyCat 作为中间件的话，可参考：<a target="_blank" rel="noopener" href="https://bbs.huaweicloud.com/blogs/343277">https://bbs.huaweicloud.com/blogs/343277</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN,en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/2024/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQL++/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/2024/11/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQL++/" class="post-title-link" itemprop="url">SQL++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-11-15 00:00:00" itemprop="dateCreated datePublished" datetime="2024-11-15T00:00:00-08:00">2024-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 21:01:48" itemprop="dateModified" datetime="2025-05-31T21:01:48-07:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">数据库系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <link rel="stylesheet" type="text&#x2F;css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css"><h1 id="Data-Model"><a href="#Data-Model" class="headerlink" title="Data Model"></a>Data Model</h1><p><strong>SQL++ has a more flexible data model:</strong></p>
<ul>
<li>It relaxes traditional SQL’s strict rules to handle modern, semi-structured data like JSON or CBOR.</li>
<li>SQL++ databases can store self-describing data, meaning you don’t need a predefined schema (data structure).</li>
</ul>
<p><strong>Supports diverse data types:</strong></p>
<ul>
<li>Data can be single values (scalars), tuples (a set of key-value pairs), collections (like arrays or multisets), or combinations of these.</li>
<li>Unlike traditional SQL, tuples in SQL++ are <strong>unordered</strong>, which means the order of attributes doesn’t matter.</li>
</ul>
<p><strong>Allows duplicate attribute names but discourages them:</strong></p>
<ul>
<li>This is to accommodate non-strict formats like JSON.</li>
<li>However, duplicate names can lead to unpredictable query results, so they’re not recommended.</li>
</ul>
<p><strong>Two kinds of missing values:</strong> <strong><code>NULL</code> and <code>MISSING</code></strong>:</p>
<ul>
<li><strong><code>NULL</code></strong>: Means an attribute exists but has no value.</li>
<li><strong><code>MISSING</code></strong>: Means the attribute doesn’t exist at all.</li>
<li>This distinction is useful for clearer query results and error handling.</li>
</ul>
<p><strong>Importance of</strong> <strong><code>MISSING</code></strong>:</p>
<ul>
<li>SQL++ doesn’t stop processing if some data is missing; instead, it marks those cases as <code>MISSING</code> and continues.</li>
<li>This makes queries more robust and tolerant of data inconsistencies.</li>
</ul>
<h1 id="Accessing-Nested-Data"><a href="#Accessing-Nested-Data" class="headerlink" title="Accessing Nested Data"></a>Accessing Nested Data</h1><p><strong>SQL-92 vs. Modern Data:</strong></p>
<ul>
<li>SQL-92 only supports tables with rows (tuples) containing simple values (scalars).</li>
<li>Modern data formats often include <strong>nested structures</strong>, where attributes can hold complex data types like arrays, tables, or even arrays of arrays.</li>
</ul>
<p><strong>Nested Data Example:</strong></p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code1.png" alt="img"></p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code2.png" alt="img"></p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code3.png" alt="img"></p>
<ul>
<li>In the example, the <code>projects</code> attribute of an employee is an <strong>array of tuples</strong>, representing multiple projects each employee is involved in.</li>
</ul>
<p><strong>Querying Nested Data in SQL++:</strong></p>
<ul>
<li>SQL++ can handle such nested data without adding new syntax to SQL.</li>
<li>For example, a query can find employees working on projects with “security” in their names and output both the employee’s name and the project’s name.</li>
</ul>
<p><strong>How It Works:</strong></p>
<ul>
<li>SQL++ uses <strong>left-correlation</strong>, allowing expressions in the <code>FROM</code> clause to refer to variables declared earlier in the same clause.</li>
<li>For instance, <code>e.projects</code> accesses the projects of an employee <code>e</code>.</li>
<li>This relaxes SQL’s restrictions and effectively enables a join between an employee and their projects.</li>
</ul>
<p><strong>Using Variables in Queries:</strong></p>
<ul>
<li>SQL++ requires <strong>explicit</strong> use of variables (e.g., <code>e.name</code> instead of just <code>name</code>) because schema is optional and cannot guarantee automatic disambiguation.</li>
<li>If a schema exists, SQL++ can still optimize by rewriting the query for clarity and execution.</li>
</ul>
<p><strong>Flexibility with Nested Collections:</strong></p>
<ul>
<li>Variables in SQL++ can represent any type of data—whether it’s a table, array, or scalar.</li>
<li>These variables can be used seamlessly in <code>FROM</code>, <code>WHERE</code>, and <code>SELECT</code> clauses.</li>
</ul>
<p><strong>Aliases Can Bind to Any Data Type:</strong></p>
<ul>
<li>In SQL++, variables (aliases) don’t have to refer only to tuples.</li>
<li>They can bind to <strong>arrays of scalars</strong>, <strong>arrays of arrays</strong>, or any combination of scalars, tuples, and arrays.</li>
</ul>
<p><strong>Flexibility in Querying Nested Data:</strong></p>
<ul>
<li>Users don’t need to learn new query syntax for different data structures.</li>
<li>The same <strong>unnesting feature</strong> is used regardless of whether the data is an array of tuples or an array of scalars.</li>
</ul>
<p>Example:</p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code4.png" alt="img"></p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code5.png" alt="img"></p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code6.png" alt="img"></p>
<ul>
<li>If the <code>projects</code> attribute is an <strong>array of strings</strong> (instead of tuples), SQL++ queries can still process it.</li>
<li>The query would range over <code>e.projects</code> and bind <code>p</code> to each project name (a string).</li>
</ul>
<p><strong>Relaxed Semantics Compared to SQL:</strong></p>
<ul>
<li>In traditional SQL, the <code>FROM</code> clause binds variables strictly to tuples.</li>
<li>SQL++ generalizes this by treating the <code>FROM</code> clause as a function that can bind variables to <strong>any type of data</strong>—not just tuples.</li>
</ul>
<p><strong>Practical Outcome:</strong></p>
<ul>
<li>In the example, the <code>FROM</code> clause produced variable bindings like <code>&#123;e: employee_data, p: project_name&#125;</code>.</li>
<li>This allows the query to handle data structures that SQL would not support without extensions.</li>
</ul>
<h1 id="ABSENCE-OF-SCHEMA-AND-SEMI-STRUCTURED-DATA"><a href="#ABSENCE-OF-SCHEMA-AND-SEMI-STRUCTURED-DATA" class="headerlink" title="ABSENCE OF SCHEMA AND SEMI-STRUCTURED DATA"></a>ABSENCE OF SCHEMA AND SEMI-STRUCTURED DATA</h1><p>Schemaless Data:</p>
<ul>
<li>Many modern data formats (e.g., JSON) don’t require a predefined schema to describe their structure.</li>
<li>This allows for <strong>flexible and diverse data</strong>, but it also introduces <strong>heterogeneity</strong>.</li>
</ul>
<p>Types of Heterogeneity:</p>
<ul>
<li><strong>Attribute presence</strong>: Some tuples may have a specific attribute (e.g., <code>x</code>), while others may not.</li>
<li><strong>Attribute type</strong>: The same attribute can have different types across tuples. For example:<ul>
<li>In one tuple, <code>x</code> might be a string.</li>
<li>In another tuple, <code>x</code> might be an array.</li>
</ul>
</li>
<li><strong>Element types in collections</strong>: A collection (e.g., an array or a bag) can have elements of different types. For example:<ul>
<li>The first element could be a string, the second an integer, and the third an array.</li>
</ul>
</li>
<li><strong>Legacy or data evolution</strong>: These heterogeneities often result from evolving requirements or data conversions (e.g., converting XML to JSON).</li>
</ul>
<p>Heterogeneity Is Not Limited to Schemaless Data:</p>
<ul>
<li>Even structured databases can have heterogeneity. For example:<ul>
<li>Hive’s <strong>union type</strong> allows an attribute to hold multiple types, like a string or an array of strings.</li>
</ul>
</li>
</ul>
<p>How SQL++ Handles It:</p>
<ul>
<li>SQL++ is designed to work seamlessly with <strong>heterogeneous data</strong>, whether the data comes from a schemaless format or a schema-based system.</li>
<li>It offers features and mechanisms to process such data flexibly, without enforcing rigid structure requirements.</li>
</ul>
<h2 id="Missing-Attributes"><a href="#Missing-Attributes" class="headerlink" title="Missing Attributes"></a>Missing Attributes</h2><ol>
<li><p><strong>Representation of Missing Information</strong>:</p>
<ul>
<li><p>In SQL, a missing value is typically represented as <code>NULL</code> (e.g., Bob Smith’s title in the first example).</p>
</li>
<li><p>In SQL++, there’s an additional option: simply omitting the attribute altogether (as seen in the second example for Bob Smith).</p>
</li>
</ul>
</li>
<li><p><code>NULL</code> <strong>vs.</strong> <code>MISSING</code>:</p>
<ul>
<li><p><code>NULL</code>: Indicates the attribute exists but has no value.</p>
</li>
<li><p><code>MISSING</code>: Indicates the attribute is entirely absent.</p>
</li>
<li><p>SQL++ supports distinguishing between these two cases, unlike traditional SQL.</p>
</li>
</ul>
</li>
<li><p><strong>Why This Matters</strong>:</p>
<ul>
<li><p>Some data systems or formats (e.g., JSON) naturally omit <strong>missing</strong> attributes rather than assigning a <code>NULL</code> value.</p>
</li>
<li><p>SQL++ makes it easy to work with both approaches by allowing queries to handle <code>NULL</code> and <code>MISSING</code> values distinctly.</p>
</li>
</ul>
</li>
<li><p><strong>Query Behavior</strong>:</p>
<ul>
<li><p>Queries in SQL++ can propagate <code>NULL</code> and <code>MISSING</code> values as they are.</p>
</li>
<li><p>The system introduces the special value <code>MISSING</code> to represent absent attributes, allowing clear differentiation from <code>NULL</code>.</p>
</li>
</ul>
</li>
</ol>
<h2 id="MISSING-as-a-Value"><a href="#MISSING-as-a-Value" class="headerlink" title="MISSING as a Value"></a>MISSING as a Value</h2><p>What Happens When Data is Missing:</p>
<ul>
<li>If a query references an attribute that doesn’t exist in a tuple (e.g., <code>e.title</code> for Bob Smith), SQL++ assigns the value <code>MISSING</code>.</li>
<li>This avoids query failures and ensures processing can continue.</li>
</ul>
<p><strong>Three Cases Where</strong> <code>MISSING</code> <strong>is Produced</strong>:</p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code7.png" alt="img"></p>
<ul>
<li><strong>Case 1</strong>: Accessing a missing attribute. For example, <code>&#123;id: 3, name: &#39;Bob Smith&#39;&#125;.title</code> results in <code>MISSING</code>.</li>
<li><strong>Case 2</strong>: Using invalid input types for functions or operators (e.g., <code>2 * &#39;some string&#39;</code>).</li>
<li><strong>Case 3</strong>: When <code>MISSING</code> is an input to a function or operator, it propagates as <code>MISSING</code> in the output.</li>
</ul>
<p>SQL Compatibility Mode:</p>
<ul>
<li>In SQL compatibility mode, <code>MISSING</code> behaves like <code>NULL</code> for compatibility. For instance, <code>COALESCE(MISSING, 2)</code> will return <code>2</code>, just as <code>COALESCE(NULL, 2)</code> does in SQL.</li>
</ul>
<p><strong>Propagation of</strong> <code>MISSING</code> <strong>in Queries</strong>:</p>
<ul>
<li>In queries, <code>MISSING</code> values flow naturally through transformations, enabling consistent handling of absent data.</li>
<li>For example, in a <code>CASE</code> statement, if <code>e.title</code> evaluates to <code>MISSING</code>, the result of the entire <code>CASE</code> expression will also be <code>MISSING</code>.</li>
</ul>
<p><strong>Results with</strong> <code>MISSING</code>:</p>
<ul>
<li>If a query result includes <code>MISSING</code>, SQL++ will omit the attribute from the result tuple.</li>
<li>In communication with external systems like JDBC&#x2F;ODBC, <code>MISSING</code> is transmitted as <code>NULL</code> to ensure compatibility.</li>
</ul>
<h1 id="RESULT-CONSTRUCTION-NESTING-AND-GROUPING"><a href="#RESULT-CONSTRUCTION-NESTING-AND-GROUPING" class="headerlink" title="RESULT CONSTRUCTION,NESTING, AND GROUPING"></a>RESULT CONSTRUCTION,NESTING, AND GROUPING</h1><h2 id="Creating-Collections-of-Any-Value"><a href="#Creating-Collections-of-Any-Value" class="headerlink" title="Creating Collections of Any Value"></a>Creating Collections of Any Value</h2><p><strong>Power of</strong> <code>SELECT VALUE</code>:</p>
<ul>
<li>The <code>SELECT VALUE</code> clause in SQL++ allows constructing collections of any type of data, not just tuples.</li>
<li>It enables creating outputs that match the structure of nested data without flattening it unnecessarily.</li>
</ul>
<p>Example Query:</p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code8.png" alt="img"></p>
<ul>
<li>The query in Listing 10 demonstrates how to use <code>SELECT VALUE</code> to extract only the “security” projects of employees, resulting in a nested structure.</li>
<li>Each employee’s tuple includes their ID, name, title, and a collection of their security-related projects.</li>
</ul>
<p>Result:</p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code9.png" alt="img"></p>
<ul>
<li>Listing 11 shows the result where each employee has a field <code>security_proj</code> containing a nested collection of projects that match the condition (e.g., projects with “Security” in the name).</li>
</ul>
<p>Key Difference from Standard SQL:</p>
<ul>
<li>SQL’s <code>SELECT</code> clause can be viewed as shorthand for <code>SELECT VALUE</code>, but with differences:<ul>
<li>SQL automatically coerces subquery results into scalar values, collections of scalars, or tuples based on context.</li>
<li>In contrast, <code>SELECT VALUE</code> in SQL++ consistently produces a collection and does not apply implicit coercion.</li>
</ul>
</li>
</ul>
<p>Flexibility:</p>
<ul>
<li>SQL++ avoids implicit “magic” by explicitly treating <code>SELECT</code> as shorthand for <code>SELECT VALUE</code>.</li>
<li>This approach aligns more closely with functional programming principles, making it easier to handle and compose nested data results.</li>
</ul>
<h2 id="GROUP-BY-and-GROUP-AS"><a href="#GROUP-BY-and-GROUP-AS" class="headerlink" title="GROUP BY and GROUP AS"></a>GROUP BY and GROUP AS</h2><p><strong>Introduction to</strong> <code>GROUP BY ... GROUP AS</code>:</p>
<ul>
<li>This feature extends SQL’s <code>GROUP BY</code> functionality, allowing groups (and their contents) to be directly accessible in the <code>SELECT</code> and <code>HAVING</code> clauses.</li>
<li>It is more efficient and intuitive for creating nested results compared to traditional SQL, especially when the output nesting doesn’t directly align with the input data structure.</li>
</ul>
<p>How It Works:</p>
<ul>
<li><strong>Generalization</strong>: Unlike SQL, which limits access to grouped data in <code>GROUP BY</code>, SQL++ allows accessing the full group details as part of the query.</li>
<li><strong>Pipeline Model</strong>: SQL++ processes queries in a step-by-step fashion, starting with <code>FROM</code>, followed by optional clauses like <code>WHERE</code>, <code>GROUP BY</code>, <code>HAVING</code>, and ending with <code>SELECT</code>.</li>
</ul>
<p>Example:</p>
<ul>
<li>In the query from <strong>Listing 12</strong>, employees are grouped by their project names (converted to lowercase), and a nested list of employees for each project is created.</li>
<li>The <code>GROUP BY LOWER(p) AS p GROUP AS g</code> clause groups data and stores each group in <code>g</code>.</li>
<li>The <code>SELECT</code> clause then extracts project names and employees.</li>
</ul>
<p>Result:</p>
<ul>
<li>The output (shown in <strong>Listing 13</strong>) contains nested objects:</li>
<li><ul>
<li>Each object has a <code>proj_name</code> (e.g., <code>&#39;OLTP Security&#39;</code>) and an <code>employees</code> field listing the names of employees associated with that project.</li>
</ul>
</li>
</ul>
<p><strong>Details of</strong> <code>GROUP BY ... GROUP AS</code>:</p>
<ul>
<li>The clause produces bindings like the ones in <strong>Listing 14</strong>, where each group (<code>g</code>) includes all the data for its corresponding key (<code>p</code>).</li>
<li>The result allows users to flexibly access and format the grouped data.</li>
</ul>
<p>SQL++ Flexibility:</p>
<ul>
<li>SQL++ allows placing the <code>SELECT</code> clause either at the start or the end of a query block, enhancing readability and flexibility.</li>
<li>This approach is more consistent with functional programming and reduces constraints found in traditional SQL.</li>
</ul>
<p>Advanced Features:</p>
<ul>
<li>SQL++ supports additional analytical tools like <code>CUBE</code>, <code>ROLLUP</code>, and <code>GROUPING SETS</code>, making it highly compatible with SQL but better suited for nested and semi-structured data.</li>
</ul>
<h2 id="Aggregate-Functions"><a href="#Aggregate-Functions" class="headerlink" title="Aggregate Functions"></a>Aggregate Functions</h2><p>Limitations of Traditional SQL Aggregate Functions:</p>
<ul>
<li>Aggregate functions like <code>AVG</code> and <code>MAX</code> in traditional SQL lack <strong>composability</strong>.</li>
<li>They work directly on table columns but don’t easily integrate with more complex expressions or subqueries.</li>
</ul>
<p>SQL++ Solution:</p>
<ul>
<li>SQL++ introduces <strong>composable aggregate functions</strong>, such as <code>COLL_AVG</code> (for calculating the average of a collection) and <code>COLL_MAX</code>.</li>
<li>These functions take a <strong>collection</strong> as input and return the aggregated value.</li>
</ul>
<p>Importance of Composability:</p>
<ul>
<li>In SQL++, data is conceptually <strong>materialized</strong> into a collection first, then passed to the composable aggregate function.</li>
<li>While this materialization is conceptual, SQL++ engines optimize the execution (e.g., using pipelined aggregation).</li>
</ul>
<p>Example 1: Calculating the Average Salary of Engineers:</p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code10.png" alt="img"></p>
<ul>
<li><strong>SQL Query</strong> (Listing 15): Uses <code>AVG(e.salary)</code> directly.</li>
<li><strong>SQL++ Core Query</strong> (Listing 16): Converts <code>e.salary</code> into a collection and applies the <code>COLL_AVG</code> function.</li>
<li>SQL++ clearly defines the flow of data, making it more intuitive and flexible.</li>
</ul>
<p>Example 2: Calculating the Average Salary of Engineers by Department:</p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code11.png" alt="img"></p>
<ul>
<li><strong>SQL Query</strong> (Listing 17): Uses <code>GROUP BY</code> and <code>AVG</code>.</li>
<li><strong>SQL++ Core Query</strong> (Listing 18):<ul>
<li>Uses <code>GROUP BY ... GROUP AS</code> to form groups.</li>
<li>Feeds each group into <code>COLL_AVG</code> to calculate the average salary.</li>
<li>Constructs the result using the <code>SELECT VALUE</code> clause, explicitly specifying the output format.</li>
</ul>
</li>
</ul>
<p>Flexibility of SQL++ Style:</p>
<ul>
<li>SQL++ allows the <code>SELECT</code> clause to be written at the end of a query block, consistent with functional programming styles.</li>
<li>This enhances readability and composability while maintaining compatibility with SQL.</li>
</ul>
<h1 id="Pivoting-and-Unpivoting"><a href="#Pivoting-and-Unpivoting" class="headerlink" title="Pivoting and Unpivoting"></a>Pivoting and Unpivoting</h1><h2 id="UNPIVOT-Transforming-Attributes-into-Rows"><a href="#UNPIVOT-Transforming-Attributes-into-Rows" class="headerlink" title="UNPIVOT: Transforming Attributes into Rows"></a>UNPIVOT: Transforming Attributes into Rows</h2><ol>
<li><p><strong>What is Unpivoting?</strong></p>
<ul>
<li><p>Unpivoting is the process of converting attribute names (used as keys) into data rows.</p>
</li>
<li><p>This is useful for cases where key-value pairs in the data need to be analyzed as individual rows.</p>
</li>
</ul>
</li>
<li><p><strong>Example (Listing 19-21)</strong>:</p>
</li>
</ol>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code12.png" alt="img"></p>
<ul>
<li><p>Input: A <code>closing_prices</code> collection where stock symbols (<code>amzn</code>, <code>goog</code>, <code>fb</code>) are attributes with prices as values.</p>
</li>
<li><p>Query (Listing 20): The <code>UNPIVOT</code> clause transforms these attributes into rows with fields for <code>symbol</code> and <code>price</code>.</p>
</li>
<li><p>Output (Listing 21): A flattened structure where each row contains the date, stock symbol, and price.</p>
</li>
</ul>
<h2 id="Pivoting"><a href="#Pivoting" class="headerlink" title="Pivoting"></a>Pivoting</h2><ol>
<li><strong>Purpose of Pivoting</strong>:<ul>
<li>Pivoting transforms rows into attributes (columns).</li>
</ul>
</li>
<li><strong>Example from Listings 23-25</strong>:</li>
</ol>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code13.png" alt="img"></p>
<ul>
<li><strong>Input (Listing 23)</strong>: Rows of <code>today_stock_prices</code> where each stock symbol and its price are separate rows.</li>
<li><strong>Query (Listing 24)</strong>: The <code>PIVOT</code> operation turns these rows into a single object, using <code>sp.symbol</code> as attribute names and <code>sp.price</code> as their values.</li>
<li><strong>Output (Listing 25)</strong>: A tuple where each stock symbol (<code>amzn</code>, <code>goog</code>, <code>fb</code>) is an attribute, and their corresponding prices are the values.</li>
</ul>
<p><strong>Combining Grouping and Pivoting</strong></p>
<ol>
<li><strong>Using Pivot with Grouping</strong>:</li>
<li><ul>
<li>Combining <code>GROUP BY</code> and <code>PIVOT</code> enables aggregation of grouped rows into a more structured output.</li>
<li>This is particularly useful when working with time-series data or hierarchical datasets.</li>
</ul>
</li>
<li><strong>Example Query (Listing 26)</strong>:</li>
</ol>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code14.png" alt="img"></p>
<p><img src="/../../images/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/SQLPP_code15.png" alt="img"></p>
<ul>
<li>Input: Data from <code>stock_prices</code> (Listing 27), which includes stock prices for multiple dates as individual rows.</li>
<li>Query:<ul>
<li>Groups the data by <code>date</code> using <code>GROUP BY sp.date</code>.</li>
<li>Pivots the grouped rows to produce a nested structure where each date contains all its stock prices as attributes.</li>
</ul>
</li>
<li>Output (Listing 28): For each date, an object with a <code>prices</code> field lists the stock symbols as attributes and their respective prices as values.</li>
</ul>
<h1 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h1><p><strong>SQL++ identifies aggregate functions as an SQL violation of functional composability. Give an example of an aggregate function and describe how it violates SQL’s functional composability.</strong></p>
<ul>
<li><p><strong>Aggregate Function</strong>:<code>COLL_AVG()</code></p>
</li>
<li><p><strong>Violation Explanation</strong>:</p>
<ul>
<li><p>In traditional SQL, aggregate functions like <code>AVG</code> processes the column and returns a single value.</p>
</li>
<li><p>In SQL++, this issue is resolved by providing <strong>composable versions</strong> of aggregate functions, such as <code>COLL_AVG</code>, which operate on collections, allowing intermediate results to flow naturally into the aggregation.</p>
</li>
</ul>
</li>
</ul>
<p><strong>With SQL++, what is the difference between NULL and Missing?</strong></p>
<p><code>NULL</code>: Indicates that an attribute exists but has no value.</p>
<p><code>MISSING</code>: Indicates that an attribute is completely absent in the data.</p>
<p><strong>True or false: One must define a schema for data prior to using SQL++.</strong> </p>
<p>False:</p>
<ul>
<li>SQL++ supports <strong>schema-optional</strong> and <strong>schema-less</strong> data formats, such as JSON.</li>
<li>While schemas can improve query optimization and validation, SQL++ can process data without requiring predefined schemas, making it highly flexible for semi-structured data use cases.</li>
</ul>
<p><strong>How does the I lease prevent a thundering herd?</strong></p>
<p>The I lease (Inhibit Lease) prevents a thundering herd problem by ensuring that only one read session at a time is allowed to query the RDBMS for a missing key-value pair in the Key-Value Store (KVS). Here’s how it works:</p>
<ol>
<li><p><strong>Thundering Herd Problem</strong>:</p>
<ul>
<li><p>When a key-value pair is not found in the KVS (a <strong>KVS miss</strong>), multiple read sessions might simultaneously query the RDBMS to fetch the value.</p>
</li>
<li><p>This can overload the RDBMS and degrade performance under high concurrency.</p>
</li>
</ul>
</li>
<li><p><strong>Role of the I Lease</strong>:</p>
<ul>
<li><p>When the first read session encounters a KVS miss, it requests an I lease for the key.</p>
</li>
<li><p>Once the I lease is granted, the KVS prevents other read sessions from querying the RDBMS for the same key.</p>
</li>
<li><p>All other read sessions must “back off” and wait for the value to be updated in the KVS by the session holding the I lease.</p>
</li>
</ul>
</li>
<li><p><strong>Result</strong>:</p>
<ul>
<li><p>The session with the I lease queries the RDBMS, retrieves the value, and populates the KVS.</p>
</li>
<li><p>Subsequent read sessions observe a <strong>KVS hit</strong> and do not need to access the RDBMS.</p>
</li>
<li><p>This mechanism avoids simultaneous RDBMS queries, effectively solving the thundering herd problem.</p>
</li>
</ul>
</li>
</ol>
<p><strong>What is the difference between invalidate and refresh&#x2F;refill for maintaining the cache consistent with the database management system?</strong></p>
<ul>
<li><strong>Invalidate</strong>: Deletes stale cache entries to prevent incorrect reads, but at the cost of forcing subsequent queries to access the RDBMS.</li>
<li><strong>Refresh&#x2F;Refill</strong>: Proactively updates the cache with new data, ensuring consistent reads while reducing future load on the RDBMS at the expense of immediate computation.</li>
</ul>
<p><strong>Describe how CAMP inserts a key-value pair in the cache.</strong></p>
<p><strong>Check Cache Capacity</strong></p>
<ul>
<li>If there is <strong>enough memory</strong> to store the new key-value pair:<ul>
<li>The pair is inserted directly into the appropriate <strong>priority group</strong> based on its cost-to-size ratio.</li>
<li>L is not updated.</li>
</ul>
</li>
<li>If the cache is <strong>full</strong>:<ul>
<li>CAMP selects one or more key-value pairs to <strong>evict</strong> based on their H(p) values.</li>
<li>It removes the pair(s) with the <strong>lowest H(p)</strong> values until there is sufficient space for the new pair.</li>
</ul>
</li>
</ul>
<p><strong>Insert the New Pair</strong></p>
<ul>
<li>The new key-value pair p is added to the cache, and its H(p) value is computed and recorded.</li>
<li>The pair is placed in the appropriate priority queue based on its cost-to-size ratio.</li>
</ul>
<p><strong>How does BG compute the SoAR of a database management system?</strong> </p>
<ol>
<li>Define the SLA.</li>
<li>Run a series of experiments with increasing numbers of threads (T) to find the peak throughput while ensuring SLA compliance.</li>
</ol>
<p>Reference: <a target="_blank" rel="noopener" href="https://escholarship.org/content/qt2bj3m590/qt2bj3m590_noSplash_084218340bb4e928c05878f04d01f04d.pdf">https://escholarship.org/content/qt2bj3m590/qt2bj3m590_noSplash_084218340bb4e928c05878f04d01f04d.pdf</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yihang Wei</p>
  <div class="site-description" itemprop="description">聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="">
      
        <option value="zh-CN" data-href="/page/3/index.html" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/page/3/index.html" selected="">
          English
        </option>
      
    </select>
  </div>

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yihang Wei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '50%',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: '#fff',
  backgroundColor: '#fff',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '明暗',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>

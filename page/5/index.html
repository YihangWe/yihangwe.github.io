<!DOCTYPE html>
<html lang="zh-CN,en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yihangwe.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
<meta property="og:type" content="website">
<meta property="og:title" content="EthanWeee">
<meta property="og:url" content="https://yihangwe.github.io/page/5/index.html">
<meta property="og:site_name" content="EthanWeee">
<meta property="og:description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Yihang Wei">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://yihangwe.github.io/page/5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>EthanWeee</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start --><script>(function() {function calculateHeight(element) {let height = 0;const items = element.children;for (let i = 0; i < items.length; i++) {height += items[i].offsetHeight || 25;const child = items[i].querySelector(".nav-child");if (child && child.style.display !== "none") {height += calculateHeight(child);}}return height;}function generateToc(lang, container) {const content = document.getElementById(lang + "-content");if (!content) return;const headers = Array.from(content.querySelectorAll("h1, h2, h3, h4, h5, h6"));if (headers.length === 0) return;const ol = document.createElement("ol");ol.className = "nav";let currentLevel = 1;let currentOl = ol;let stack = [ol];let counters = [0, 0, 0, 0, 0, 0];headers.forEach((header, index) => {const level = parseInt(header.tagName[1]);counters[level - 1]++;for (let i = level; i < 6; i++) counters[i] = 0;const li = document.createElement("li");li.className = "nav-item nav-level-" + level;if (level === 1 && index === 0) {li.classList.add("active", "active-current");}const link = document.createElement("a");link.className = "nav-link";if (level === 1 && index === 0) link.classList.add("active");link.href = "#" + header.id;const numSpan = document.createElement("span");numSpan.className = "nav-number";numSpan.textContent = counters.slice(0, level).filter(n => n > 0).join(".");const textSpan = document.createElement("span");textSpan.className = "nav-text";textSpan.textContent = header.textContent;link.appendChild(numSpan);link.appendChild(document.createTextNode(" "));link.appendChild(textSpan);li.appendChild(link);if (level > currentLevel) {const newOl = document.createElement("ol");newOl.className = "nav-child";if (currentLevel === 1) {newOl.style.display = "block";stack[currentLevel - 1].lastElementChild.classList.add("active");}stack[currentLevel - 1].lastElementChild.appendChild(newOl);stack[level - 1] = newOl;currentOl = newOl;} else if (level < currentLevel) {currentOl = stack[level - 1];}currentOl.appendChild(li);currentLevel = level;});container.appendChild(ol);setTimeout(() => {const navHeight = calculateHeight(ol);ol.style.setProperty("--height", navHeight + "px");const navChilds = ol.getElementsByClassName("nav-child");Array.from(navChilds).forEach(child => {if (child.style.display === "block") {const childHeight = calculateHeight(child);child.style.setProperty("--height", childHeight + "px");}});}, 0);return ol;}function updateActiveHeading() {const activeLang = document.getElementById("en-content").style.display === "block" ? "en" : "zh";const content = document.getElementById(activeLang + "-content");const toc = document.getElementById(activeLang + "-toc");if (!content || !toc) return;const headers = Array.from(content.querySelectorAll("h1, h2, h3, h4, h5, h6"));const scrollPos = window.scrollY + window.innerHeight / 3;let activeHeader = null;for (let i = headers.length - 1; i >= 0; i--) {const header = headers[i];const headerTop = header.getBoundingClientRect().top + window.scrollY;if (headerTop <= scrollPos) {activeHeader = header;break;}}const links = toc.getElementsByClassName("nav-link");Array.from(links).forEach(link => {link.classList.remove("active");const parentLi = link.parentElement;if (parentLi) {parentLi.classList.remove("active", "active-current");}});if (activeHeader) {const activeLink = toc.querySelector(`a[href="#${activeHeader.id}"]`);if (activeLink) {activeLink.classList.add("active");let parent = activeLink.parentElement;while (parent && parent.classList) {if (parent.classList.contains("nav-item")) {parent.classList.add("active");if (parent.classList.contains("nav-level-1")) {parent.classList.add("active-current");}}parent = parent.parentElement;}}}}function initTippy() {document.querySelectorAll(".refplus-num").forEach((ref) => {if (ref._tippy) {ref._tippy.destroy();}let refid = ref.firstChild.href.replace(location.origin+location.pathname,"");let refel = document.querySelector(refid);if (!refel) return;let refnum = refel.dataset.num;let ref_content = refel.innerText.replace(`[${refnum}]`,"");tippy(ref, {content: ref_content,});});}function initToc() {const originalToc = document.querySelector(".post-toc-wrap");if (!originalToc || !document.getElementById("langToggle")) return;const tocContainer = document.createElement("div");tocContainer.className = "post-toc-wrap sidebar-panel sidebar-panel-active";const enToc = document.createElement("div");enToc.id = "en-toc";enToc.className = "post-toc motion-element";enToc.style.display = "block";const zhToc = document.createElement("div");zhToc.id = "zh-toc";zhToc.className = "post-toc motion-element";zhToc.style.display = "none";generateToc("en", enToc);generateToc("zh", zhToc);tocContainer.appendChild(enToc);tocContainer.appendChild(zhToc);originalToc.parentNode.replaceChild(tocContainer, originalToc);window.addEventListener("scroll", updateActiveHeading);setTimeout(updateActiveHeading, 0);}window.toggleLanguage = function() {const enContent = document.getElementById("en-content");const zhContent = document.getElementById("zh-content");const enToc = document.getElementById("en-toc");const zhToc = document.getElementById("zh-toc");const button = document.getElementById("langToggle");if (!enContent || !zhContent || !enToc || !zhToc || !button) return;const isEnglish = enContent.style.display === "block";enContent.style.display = isEnglish ? "none" : "block";zhContent.style.display = isEnglish ? "block" : "none";enToc.style.display = isEnglish ? "none" : "block";zhToc.style.display = isEnglish ? "block" : "none";button.querySelector(".button-text").textContent = isEnglish ? "Switch to English" : "切换中文";setTimeout(updateActiveHeading, 0);setTimeout(initTippy, 100);};document.addEventListener("DOMContentLoaded", function() {initToc();setTimeout(initTippy, 3000);});})();</script><style>.post-toc { transition: all 0.2s ease-in-out; }.post-toc .nav { padding-left: 0; }.post-toc .nav-child { padding-left: 1em; }.post-toc .nav-item { line-height: 1.8; }.post-toc .nav-link { color: #555; }.post-toc .nav-link:hover { color: #222; }.post-toc .nav-link.active { color: #fc6423; }.post-toc .active > .nav-link { color: #fc6423; }.post-toc .active-current > .nav-link { color: #fc6423; }</style><!-- hexo injector head_end end --><style>.darkmode--activated{--body-bg-color:#282828;--content-bg-color:#333;--card-bg-color:#555;--text-color:#ccc;--blockquote-color:#bbb;--link-color:#ccc;--link-hover-color:#eee;--brand-color:#ddd;--brand-hover-color:#ddd;--table-row-odd-bg-color:#282828;--table-row-hover-bg-color:#363636;--menu-item-bg-color:#555;--btn-default-bg:#222;--btn-default-color:#ccc;--btn-default-border-color:#555;--btn-default-hover-bg:#666;--btn-default-hover-color:#ccc;--btn-default-hover-border-color:#666;--highlight-background:#282b2e;--highlight-foreground:#a9b7c6;--highlight-gutter-background:#34393d;--highlight-gutter-foreground:#9ca9b6}.darkmode--activated img{opacity:.75}.darkmode--activated img:hover{opacity:.9}.darkmode--activated code{color:#69dbdc;background:0 0}button.darkmode-toggle{z-index:9999}.darkmode-ignore,img{display:flex!important}.beian img{display:inline-block!important}</style></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">EthanWeee</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN,en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/MySQL/2024/10/20/MySQL/%E8%A7%A6%E5%8F%91%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/MySQL/2024/10/20/MySQL/%E8%A7%A6%E5%8F%91%E5%99%A8/" class="post-title-link" itemprop="url">触发器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-20T00:00:00-07:00">2024-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-17 22:19:44" itemprop="dateModified" datetime="2025-06-17T22:19:44-07:00">2025-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 insert &#x2F; update &#x2F; delete 之前或之后，触发并执行触发器中定义的 SQL 语句集合。</p>
<p>确保数据完整性，日志记录，数据校验等操作。</p>
<p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容。</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW 和 OLD</th>
</tr>
</thead>
<tbody><tr>
<td>Insert 型</td>
<td>NEW 表示将要或已经新增的数据</td>
</tr>
<tr>
<td>Update 型</td>
<td>OLD 表示修改之前的数据，NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>Delete 型</td>
<td>OLD 表示将要或已经删除的数据</td>
</tr>
</tbody></table>
<p>行级触发器：触发次数等于影响的行数。</p>
<p>语句级触发器：不论影响的行数，只触发一次。</p>
<p>MySQL触发器只支持<strong>行级触发</strong>，不支持语句级触发。</p>
<p>创建</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name</span><br><span class="line">before <span class="operator">/</span> after <span class="keyword">insert</span> <span class="operator">/</span> <span class="keyword">update</span> <span class="operator">/</span> <span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> table_name <span class="keyword">for</span> <span class="keyword">each</span> <span class="type">row</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">SQL</span> 语句;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>查看：<code>show triggers;</code></p>
<p>删除：<code>drop trigger [schema_name]trigger_name;</code></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN,en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/MySQL/2024/10/17/MySQL/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/MySQL/2024/10/17/MySQL/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/" class="post-title-link" itemprop="url">存储过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-17 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-17T00:00:00-07:00">2024-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-17 22:15:05" itemprop="dateModified" datetime="2025-06-17T22:15:05-07:00">2025-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>存储过程是事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输。</p>
<p>特点：</p>
<ol>
<li>封装，复用。</li>
<li>可接收参数，也可返回数据。</li>
<li>减少网络交互，效率提升。</li>
</ol>
<p>创建：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称(参数列表)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">SQL</span>语句;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>调用：<code>call 名称(参数列表);</code></p>
<p>查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.routines <span class="keyword">where</span> routine_schema <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>删除：<code>drop procedure [if exists] 存储过程名称;</code></p>
<p>在 MySQL 命令行客户端中执行创建存储过程的 SQL 时，需要通过关键字 delimiter 指定 SQL 语句的结束符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line">create procedure 存储过程名称(参数列表)</span><br><span class="line">begin</span><br><span class="line">  SQL语句;</span><br><span class="line">end $$</span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>系统变量</strong></p>
<p>由MySQL 服务器提供，属于服务器层面。</p>
<ul>
<li>全局变量（global）</li>
<li>会话变量（session）</li>
</ul>
<p>查看系统变量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> [session <span class="operator">|</span> <span class="keyword">global</span>] variables;</span><br><span class="line"><span class="keyword">show</span> [session <span class="operator">|</span> <span class="keyword">global</span>] variables <span class="keyword">like</span> <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> @@[session. <span class="operator">|</span> global.] 系统变量名;</span><br></pre></td></tr></table></figure>

<p>设置系统变量：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> [session <span class="operator">|</span> <span class="keyword">global</span>] 系统变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> @@[session <span class="operator">|</span> <span class="keyword">global</span>] 系统变量名 <span class="operator">=</span> 值;</span><br></pre></td></tr></table></figure>

<p>如果没有指定 session&#x2F;global，默认是 session，也就是会话变量。</p>
<p>MySQL 服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在 &#x2F;etc&#x2F;my.cnf 中配置。</p>
<p><strong>自定义变量</strong></p>
<p>无需提前声明，格式为 <code>@变量名</code>，作用域为当前连接。</p>
<p>赋值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span><span class="operator">=</span>expr [, <span class="variable">@var_name</span><span class="operator">=</span>expr] ...;</span><br><span class="line"><span class="keyword">set</span> <span class="variable">@var_name</span>:<span class="operator">=</span>expr [, <span class="variable">@var_name</span>:<span class="operator">=</span>expr] ...;</span><br><span class="line"><span class="keyword">select</span> <span class="variable">@var_name</span>:<span class="operator">=</span>expr [, <span class="variable">@var_name</span>:<span class="operator">=</span>expr] ...;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> <span class="variable">@var_name</span> <span class="keyword">from</span> 表名; <span class="comment">-- 把从表中获取的数据赋值给变量</span></span><br></pre></td></tr></table></figure>

<p>使用：<code>select @var_name;</code></p>
<p>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为 NULL，但是不会报错。</p>
<p><strong>局部变量</strong></p>
<p>在局部生效的变量，访问之前需要先通过 declare 声明，可用作存储过程的局部变量和输入参数，作为局部变量的话，范围是在 <code>begin … end</code> 块内。</p>
<p>声明：<code>declare 变量名 变量类型 [default ...];</code></p>
<p>赋值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">set</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">select</span> 字段名 <span class="keyword">into</span> 变量名 <span class="keyword">from</span> 表名 ...;</span><br></pre></td></tr></table></figure>

<h2 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">If 条件<span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">...</span><br><span class="line">Elseif 条件<span class="number">2</span> <span class="keyword">then</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">Else</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">End</span> If</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>类型</p>
<ul>
<li>IN：输入参数。</li>
<li>OUT：输出参数。</li>
<li>INOUT：输入输出参数皆可。</li>
</ul>
<p>用法</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称([<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">SQL</span> 语句</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><p>语法 1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> case_value</span><br><span class="line"><span class="keyword">when</span> value1 <span class="keyword">then</span> statement_list1</span><br><span class="line">[<span class="keyword">when</span> value2 <span class="keyword">then</span> statement_list2] ...</span><br><span class="line">[<span class="keyword">else</span> statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure>

<p>语法 2</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span></span><br><span class="line"><span class="keyword">when</span> search_condition1 <span class="keyword">then</span> statement_list1</span><br><span class="line">[<span class="keyword">when</span> search_condition2 <span class="keyword">then</span> statement_list2] ...</span><br><span class="line">[<span class="keyword">else</span> statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br></pre></td></tr></table></figure>

<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while 条件 do</span><br><span class="line">  <span class="keyword">SQL</span> 语句</span><br><span class="line"><span class="keyword">end</span> while;</span><br></pre></td></tr></table></figure>

<h2 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">  <span class="keyword">SQL</span> 语句</span><br><span class="line">until 条件</span><br><span class="line"><span class="keyword">end</span> repeat;</span><br></pre></td></tr></table></figure>

<h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[label]: loop</span><br><span class="line">	<span class="keyword">SQL</span> 语句</span><br><span class="line"><span class="keyword">end</span> loop [label];</span><br></pre></td></tr></table></figure>

<p><code>leave label;</code> 退出指定标记的循环体（类似于 break）<br><code>iterate label;</code> 直接进入下一次循环（类似于 continue）</p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环处理。</p>
<ul>
<li>声明游标：<code>declare 游标名称 cursor for 查询语句;</code></li>
<li>打开游标：<code>open 游标名称;</code></li>
<li>获取游标记录：<code>fetch 游标名称 into 变量 [, 变量];</code></li>
<li>关闭游标：<code>close 游标名称;</code></li>
</ul>
<h2 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h2><p>用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> handler_action handler <span class="keyword">for</span> condition_value [, condition_value]... statement;</span><br></pre></td></tr></table></figure>

<ul>
<li>handler action:<ul>
<li><code>continue</code>：继续执行当前程序。</li>
<li><code>exit</code>：终止执行当前程序。</li>
</ul>
</li>
<li><code>condition_value</code><ul>
<li><code>SQLSTATE sqlstate_value</code>：状态码，如 02000。</li>
<li><code>SQLWARNING</code>：所有以 01 开头的 SQLSTATE 代码的简写。</li>
<li><code>NOTFOUND</code>：所有以 02 开头的 SQLSTATE 代码的简写。</li>
<li><code>SQLEXCEPTION</code>：所有没有被 SQLWARNING 和 NOTFOUND 捕获的 SQLSTATE 代码的简写。</li>
</ul>
</li>
</ul>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br></pre></td></tr></table></figure>

<p>该 SQL 声明了一个条件处理程序，当满足SQL 状态码为 02000 时，先关闭游标，然后执行退出操作。</p>
<p>存储函数是有返回值的存储过程，参数只能是 IN 类型的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 存储函数名称([参数列表])</span><br><span class="line"><span class="keyword">returns</span> type [characteristic ...]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">SQL</span>语句;</span><br><span class="line">  <span class="keyword">return</span> ...;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>characteristic 说明：</p>
<ul>
<li>deterministic：返回值类型和传入值类型相同。</li>
<li>NO SQL：不包含 SQL 语句。</li>
<li>READS SQL DATA： 只包含读取数据的 SQL 语句，不包含修改数据的 SQL 语句。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN,en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/MySQL/2024/10/12/MySQL/%E8%A7%86%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/MySQL/2024/10/12/MySQL/%E8%A7%86%E5%9B%BE/" class="post-title-link" itemprop="url">视图</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-12 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-12T00:00:00-07:00">2024-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-17 22:09:09" itemprop="dateModified" datetime="2025-06-17T22:09:09-07:00">2025-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在 MySQL 数据库中，视图（View）是一个命名的虚表，它由一个 SQL 查询来定义，可以当做表使用。与持久表（permanent table）不同的是，视图中的数据没有实际的物理存储。也就是说视图中的数据并不在数据库中实际存在，行和列的数据来自定义视图的查询中使用的表，在使用视图时动态生成的。</p>
<p>视图只保存了查询的 SQL 逻辑，不保存查询结果。</p>
<h2 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h2><p>视图在数据库中发挥着重要的作用。视图的主要用途之一是被用做一个抽象装置，特别是对于一些应用程序，程序本身不需要关心基表（base table）的结构，只需要按照视图定义来取数据或更新数据；因此，视图同时在一定程度上起到一个安全层的作用。</p>
<p>MySQL 数据库 DBA 的一个常用的命令是 SHOW TABLES，该命令会显示出当前数据库下所有的表。但因为视图是虚表，同样被作为表显示出来。若用户只想查看当前架构下的基表，可以通过 information_schema 架构下的 TABLES 表来查询，并搜索表类型为 BASE TABLE 的表。</p>
<p>要想查看视图的一些元数据（meta data），可以访问 information_schema 架构下的 VIEWS 表，该表给出了视图的详细信息，包括视图定义者（definer）、定义内容、是否是可更新视图、字符集等。</p>
<p>创建：<code>create [or replace] view 视图名称 as select 语句 [with cascaded | local check option];</code></p>
<p>查询：</p>
<ul>
<li>查看创建视图的语句：<code>show create view 视图名称;</code></li>
<li>查看视图数据：<code>select * from 视图名称...;</code></li>
</ul>
<p>修改：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">or</span> replace] <span class="keyword">view</span> 视图名称 <span class="keyword">as</span> <span class="keyword">select</span> 语句 [<span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span> <span class="keyword">check</span> option];</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称 <span class="keyword">as</span> <span class="keyword">select</span> 语句 [<span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="operator">|</span> <span class="keyword">local</span> <span class="keyword">check</span> option];</span><br><span class="line"># 实际上数据行是被插入了基表当中</span><br><span class="line"><span class="keyword">insert into</span> 视图名称 <span class="keyword">values</span>(col1, col2, ...); </span><br></pre></td></tr></table></figure>

<p>删除：<code>drop view [if exist] 视图名称;</code></p>
<h2 id="视图的检查选项"><a href="#视图的检查选项" class="headerlink" title="视图的检查选项"></a>视图的检查选项</h2><p>当时用 <code>with check option</code> 子句创建视图时，MySQL 会通过视图检查正在更改的每一行，以使其符合视图的定义。MySQL 允许基于一个视图创建另一个视图，还会依赖视图中的规则以保持一致性。MySQL 提供了两个选项确定检查范围：cascaded 和 local，默认值为 cascaded。</p>
<h2 id="视图的更新"><a href="#视图的更新" class="headerlink" title="视图的更新"></a>视图的更新</h2><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。</p>
<p>如果视图包含以下任何一项，该视图不可更新：</p>
<ul>
<li>聚合函数或窗口函数：<code>sum()</code>，<code>min()</code>，<code>max()</code>，<code>count()</code>；</li>
<li><code>distinct</code>；</li>
<li><code>group by</code>；</li>
<li><code>having</code>；</li>
<li><code>union</code> 或 <code>union all</code>。</li>
</ul>
<p>视图可以简化用户对数据的理解，以及简化操作。</p>
<p>通过视图，用户只能查询和修改他们所能见到的数据。</p>
<p>视图帮助用户屏蔽真实表结构变化带来的影响。</p>
<h2 id="物化视图"><a href="#物化视图" class="headerlink" title="物化视图"></a>物化视图</h2><p>Oracle 数据库支持物化视图——该视图不是基于基表的虚表，而是根据基表实际存在的实表，即物化视图的数据存储在非易失的存储设备上。物化视图可用于预先计算并保存多表的连接（JOIN）或聚集（GROUP BY）等耗时较多的 SQL 操作结果。这样，在执行复杂查询时，就可以避免进行这些时耗的操作，从而快速得到结果。物化视图的好处是对于一些复杂的统计类查询能直接给出结果。在 Microsoft SQL Server 数据库中，称这种视图为索引视图。</p>
<p>在 Oracle 数据库中，物化视图的创建方式包括以下两种：</p>
<ul>
<li><code>BUILD IMMEDIATE</code></li>
<li><code>BUILD DEFERRED</code></li>
</ul>
<p><code>BUILD IMMEDIATE</code> 是默认的创建方式，在创建物化视图的时候就生成数据，而 <code>BUILD DEFERRED</code> 则在创建物化视图时不生成数据，以后根据需要再生成数据。</p>
<p>查询重写是指当对物化视图的基表进行查询时，数据库会自动判断能否通过查询物化视图来直接得到最终的结果，如果可以，则避免了聚集或连接等这类较为复杂的 SQL 操作，直接从已经计算好的物化视图中得到所需的数据。</p>
<p>物化视图的刷新是指当基表发生了 DML 操作后，物化视图何时采用哪种方式和基表进行同步。刷新模式有两种：</p>
<ul>
<li><code>ON DEMAND</code></li>
<li><code>ON COMMIT</code></li>
</ul>
<p><code>ON DEMAND</code> 意味着物化视图在用户需要的时候进行刷新，ON COMMIT 意味着物化视图在对基表的 DML 操作提交的同时进行刷新。</p>
<p>而刷新的方法有四种：</p>
<ul>
<li><code>FAST</code></li>
<li><code>COMPLETE</code></li>
<li><code>FORCE</code></li>
<li><code>NEVER</code></li>
</ul>
<p>FAST 刷新采用增量刷新，只刷新自上次刷新以来进行的修改。COMPLETE 刷新是对整个物化视图进行完全的刷新。如果选择 FORCE 方式，则数据库在刷新时会去判断是否可以进行快速刷新，如果可以，则采用 FAST 方式，否则采用 COMPLETE 的方式。NEVER 是指物化视图不进行任何刷新。</p>
<p><strong>MySQL 数据库本身并不支持物化视图</strong>，换句话说，MySQL 数据库中的视图总是虚拟的。但是用户可以通过一些机制来实现物化视图的功能。例如要创建一个 ON DEMAND 的物化视图还是比较简单的，用户只需定时把数据导入到另一张表。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN,en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/2024/10/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/OCC%20%E5%92%8C%20MVCC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/2024/10/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/OCC%20%E5%92%8C%20MVCC/" class="post-title-link" itemprop="url">OCC 和 MVCC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-11 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-11T00:00:00-07:00">2024-10-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-05-31 01:18:09" itemprop="dateModified" datetime="2025-05-31T01:18:09-07:00">2025-05-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">数据库系统</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Time-Stamp-Based-Protocols"><a href="#Time-Stamp-Based-Protocols" class="headerlink" title="Time-Stamp Based Protocols"></a>Time-Stamp Based Protocols</h1><p>Suppose transaction Ti issues read(Q):</p>
<ul>
<li>If TS(Ti) &lt; W-TimeStamp(Q), then Ti needs to read the value of Q which was already overwritten. Hence the read request is rejected and Ti is rolled back.</li>
<li>If TS(Ti) &gt;&#x3D; W-TimeStamp(Q), then the read operation is executed and the R-timeStamp(Q) is set to the maximum of R-TimeStamp(Q) and TS(Ti).</li>
</ul>
<p>Suppose transaction Ti issues write(Q):</p>
<ul>
<li>If TS(Ti) &lt; R-TimeStamp(Q), then this implies that some transaction has already consumed the value of Q and Ti should have produced a value before that transaction read it. Thus, the write request is rejected and Ti is rolled back.</li>
<li>If TS(Ti) &lt; W-TimeStamp(Q), then Ti is trying to write an obsolete value of Q. Hence reject Ti’s request and roll it back. &#x2F; Ignore this write operation. (Tomas’s Write Rule)</li>
<li>Otherwise, execute the write(Q) operation and update W-TimeStamp(Q) to TS(Ti).</li>
</ul>
<h1 id="OCC"><a href="#OCC" class="headerlink" title="OCC"></a>OCC</h1><p>Each transaction Ti has three phases:</p>
<ul>
<li>Read phase: reads the value of data items and copies its contents to variables local to Ti. All writes are performed on the temporary local variables.</li>
<li>Validation phase: Ti determines whether the local variables whose values have been overwritten can be copied to the database. If not, then abort. Otherwise, proceed to Write phase.</li>
<li><ul>
<li>When validating transaction Tj, for all transactions Ti with TS(Ti) &lt; TS(Tj), one of the following must hold:</li>
<li><ul>
<li>Finish(Ti) &lt; Start(Tj), OR</li>
<li>Set of data items written by Ti does not intersect with the set of data items read by Tj, and Ti completes its write phase before Tj starts its validation phase.</li>
</ul>
</li>
</ul>
</li>
<li>Write phase: The values stored in local variables overwrite the value of the data items in the database.</li>
</ul>
<p>A transaction has three time stamps:</p>
<ul>
<li>Start(Ti): When Ti started its execution.</li>
<li>Validation(Ti): When Ti finished its read phase and started its validation.</li>
<li>Finish(Ti): Done with the write phase.</li>
</ul>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>Assume that transaction Ti issues either a read(Q) or a write(Q) operation.</p>
<p>Let Qk denote the version of Q whose write timestamp is the largest write timestamp less than TS(Ti), i.e., W-TimeStamp(Qk) &lt; TS(Ti).</p>
<ul>
<li>If Ti issues a Read(Q), then return the value of Qk.</li>
<li>If Ti issues a write(Q), and TS(Ti) &lt; R-TimeStamp(Qk), then Ti is rolled back.</li>
<li>Otherwise, a new version of Qk is created.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN,en">
    <link itemprop="mainEntityOfPage" href="https://yihangwe.github.io/undefined/MySQL/2024/10/09/MySQL/SQL%20%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Yihang Wei">
      <meta itemprop="description" content="聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="EthanWeee">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/undefined/MySQL/2024/10/09/MySQL/SQL%20%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">SQL 优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-10-09 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-09T00:00:00-07:00">2024-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-17 22:01:44" itemprop="dateModified" datetime="2025-06-17T22:01:44-07:00">2025-06-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在阐述 SQL 的优化方案之前，我们需要先了解 SQL 的执行流程，如下：</p>
<ol>
<li><p>客户端发送 SQL 语句给 MySQL 服务器。</p>
</li>
<li><p>如果查询缓存打开则会优先查询缓存，如果缓存中有对应的结果，直接返回给客户端。不过，MySQL 8.0 版本已经移除了查询缓存。</p>
</li>
<li><p>分析器对 SQL 语句进行语法分析，判断是否有语法错误。</p>
</li>
<li><p>明确 SQL 语句的目的后，MySQL 通过优化器生成执行计划。优化器通过成本计算预估出执行效率最高的方式，基本的预估维度为：</p>
</li>
<li><p>IO 成本：</p>
<ol>
<li>数据量越大，IO 成本越高，所以要避免 <code>select *</code>；尽量分页查询。</li>
<li>尽量通过索引加快查询。</li>
</ol>
</li>
<li><p>CPU 成本：</p>
<ol>
<li>尽量避免复杂的查询条件，如有必要，考虑对子查询结果进行过滤。</li>
<li>尽量缩减计算成本，比如说为排序字段加上索引，提高排序效率；比如说使用 union all 替代 union，减少去重处理。</li>
</ol>
</li>
<li><p>执行器调用存储引擎的接口，执行 SQL 语句。</p>
</li>
</ol>
<h2 id="SQL-性能分析工具"><a href="#SQL-性能分析工具" class="headerlink" title="SQL 性能分析工具"></a>SQL 性能分析工具</h2><p>如果要查询某一类 SQL 语句的执行频率，比如查看当前数据库的增删改查操作的访问频次，我们可以使用如下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span> <span class="operator">|</span> SESSION] STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;Com_%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>慢查询日志</strong>记录了执行时间超过指定参数（<code>long_query_time</code>，单位：秒，默认 10 秒）的所有 SQL 语句。</p>
<p>慢查询日志默认不开启，所以我们需要在配置文件 <code>/etc/my.cnf</code> 中配置如下信息来启动慢查询日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slow_query_log = 1</span><br><span class="line"></span><br><span class="line">long_query_time = 2 # 执行时间超过 2s 的操作被记录到慢查询日志当中</span><br></pre></td></tr></table></figure>

<p>profile 详情（默认关闭），该功能可以帮助了解 SQL 语句耗时的部分。比如：</p>
<ul>
<li>查看每一条 SQL 的耗时基本情况：<strong>SHOW</strong> <strong>PROFILES</strong>;</li>
<li>查看指定 query_id 的 SQL 语句各个阶段的耗时情况（或CPU 使用情况）：<code>show profile [cpu] for query query_id;</code></li>
<li>查看是否支持 profile 操作：<code>SELECT @@have_profiling;</code></li>
</ul>
<p>如果需要开启 profile 操作，我们可以设置：<code>SET profiling = 1;</code></p>
<p><code>EXPLAIN SELECT SQL语句;</code> 可以获取 MySQL 如何执行 SELECT 语句的信息，包括 SELECT 语句执行过程中表如何连接和连接的顺序，也就是该 SQL 语句的执行计划的细节。</p>
<p><img src="/../../images/MySQL/explain.png" alt="img"></p>
<p>上图展示了 explain 语句的结果中的各个字段，这些字段的含义如下表：</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>id</strong></td>
<td>表示查询中执行 <code>SELECT</code> 子句或操作表的顺序。<br>– <code>id</code> 相同：按顺序从上到下执行。<br>– <code>id</code> 不同：数值越大越优先执行。</td>
</tr>
<tr>
<td><strong>select_type</strong></td>
<td>表示 <code>SELECT</code> 的类型：<br>– <code>SIMPLE</code>: 简单查询，不使用 <code>JOIN</code> 或子查询。<br>– <code>PRIMARY</code>: 主查询，即最外层查询。<br>– <code>UNION</code>: <code>UNION</code> 中第二个或后面的查询。<br>– <code>SUBQUERY</code>: 在 <code>SELECT</code> &#x2F; <code>WHERE</code> 后包含子查询。<br>– <code>DERIVED</code>: 派生表的 <code>SELECT</code>（<code>FROM</code> 子句中的子查询）。</td>
</tr>
<tr>
<td><strong>table</strong></td>
<td>查询的表名。</td>
</tr>
<tr>
<td><strong>type</strong></td>
<td>表示连接类型，性能由好到差：<br>– <code>system</code>: 表只有一行，通常是系统表，速度最快。<br>– <code>const</code>, <code>eq_ref</code>, <code>ref</code>: 使用索引查找单个行，<code>const</code> 最优。<br>– <code>range</code>: 检索给定范围的行。<br>– <code>index</code>: 遍历索引树读取。<br>– <code>ALL</code>: 全表扫描，效率最低。</td>
</tr>
<tr>
<td><strong>possible_keys</strong></td>
<td>显示该表可能会使用的索引（一个或多个），但不一定真的被使用。</td>
</tr>
<tr>
<td><strong>key</strong></td>
<td>实际使用的索引；如果为 <code>NULL</code>，则未使用索引。</td>
</tr>
<tr>
<td><strong>key_len</strong></td>
<td>索引中使用的字节数，是索引字段的最大可能长度，并非实际长度；值越短越好。</td>
</tr>
<tr>
<td><strong>ref</strong></td>
<td>用于与索引列比较的值来源：<br>– <code>const</code>: 常量（如 <code>WHERE column = &#39;value&#39;</code>）。<br>– 列名称：通常在 <code>JOIN</code> 操作中，表示 <code>JOIN</code> 条件依赖的字段。<br>– <code>NULL</code>: 未使用索引或全表扫描。</td>
</tr>
<tr>
<td><strong>rows</strong></td>
<td>估算为得到结果集需扫描的行数，越少越好。</td>
</tr>
<tr>
<td><strong>filtered</strong></td>
<td>表示返回结果行数占扫描行数的百分比，越大越好。</td>
</tr>
<tr>
<td><strong>Extra</strong></td>
<td>其他信息：<br>– <code>using index condition</code> &#x2F; <code>NULL</code>: 查找使用了索引，但需回表查询数据。<br>– <code>using where, using index</code>: 查找使用了索引，且所需数据都在索引列中，无需回表。<br>– <code>using temporary</code>: 使用临时表存储中间结果。</td>
</tr>
</tbody></table>
<p>示例：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>user</td>
<td>NULL</td>
<td>range</td>
<td>PRIMARY</td>
<td>PRIMARY</td>
<td>4</td>
<td>NULL</td>
<td>6</td>
<td>100.00</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>通过 explain 命令，我们能分析出一些慢 SQL 的常见原因：</p>
<p>首先是索引使用问题，我们可通过 possible_keys(预计使用的索引) 和 key(实际使用的索引) 两个字段查看 InnoDB 有没有使用索引，优化器是否选择了错误索引，以及有没有实现覆盖索引。</p>
<p>接着是 I&#x2F;O 开销问题，通过 rows(执行当前查询要遍历的行数) 和 filtered(有效行数&#x2F;扫描行数比值) 字段来查看，是否扫描的行数过多，是否返回无用列且无用列有明显 I&#x2F;O 性能开销(比如text、blob、json 等类型）。</p>
<p><code>optimizer_trace</code> 可用于跟踪执行语句的解析、优化、执行的全过程。</p>
<p>使用步骤：</p>
<ul>
<li>查看系统变量信息：<code>show variables like &#39;%optimizer_trace%&#39;;</code></li>
<li>打开 optimizer trace 开关：<code>set optimizer_trace=&quot;enabled=on&quot;;</code></li>
<li>执行 SQL 语句。</li>
<li>查看 INFORMATION_SCHEMA.OPTIMIZER_TRACE 表中跟踪结果：<code>select * from INFORMATION_SCHEMA.OPTIMIZER_TRACE;</code>，并分析执行树：<ul>
<li><code>join_preparation</code>：准备阶段；</li>
<li><code>join_optimization</code>：分析阶段；</li>
<li><code>join_execution</code>：执行阶段。</li>
</ul>
</li>
</ul>
<p>关闭该功能：<code>set optimizer_trace=&quot;enabled=off&quot;;</code></p>
<h2 id="定位慢-SQL"><a href="#定位慢-SQL" class="headerlink" title="定位慢 SQL"></a>定位慢 SQL</h2><p>定位和优化慢 SQL 是提升 MySQL 性能的关键环节。通常可通过以下四大步骤完成：</p>
<ol>
<li>慢查询日志：记录所有执行时间超过阈值的 SQL，并借助 mysqldumpslow 汇总分析；</li>
<li>服务监控：在应用层面通过字节码插桩、连接池或 ORM 拦截对慢 SQL 进行实时监控与告警；</li>
<li>SHOW PROCESSLIST：在数据库层面查看当前运行的会话及其执行时间，快速锁定长时间运行的语句；</li>
<li>EXPLAIN：对疑似慢 SQL 执行 EXPLAIN，洞察查询执行计划，从而发现索引缺失、全表扫描等根本原因。</li>
</ol>
<p><img src="/../../images/MySQL/sql_optimize.png" alt="img"></p>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>覆盖索引指的是当查询所需字段全部存在于索引叶节点时，数据库可以仅依赖索引而无需回表读取，显著降低 I&#x2F;O 开销。因此我们需要避免不必要的列，只查询需要的列。</p>
<p>创建联合索引能使多个查询字段同时被索引覆盖，从而避免回表和索引合并操作，且应遵循最左前缀规则以确保索引被有效利用。</p>
<p>为了保持索引的可用性，应避免使用 <code>!=</code>、<code>&lt;&gt;</code> 等非等值算符以及在索引列上应用函数，因为这些写法会导致索引失效，全表扫描或全索引扫描，从而影响性能。</p>
<p>当对较长字符串字段建立前缀索引时，可节省存储空间，但由于前缀索引无法存储完整值，MySQL 无法利用其实现排序或分组操作，依然可能触发 filesort 或临时表。</p>
<p>此外，InnoDB 默认启用索引下推技术（ICP），能将部分过滤条件下放至存储引擎层，仅在满足索引列过滤的记录上执行回表，从而减少数据传输量与回表次数，进一步提升查询效率。</p>
<p>假设我要执行如下命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">30</span> <span class="keyword">AND</span> city <span class="operator">=</span> <span class="string">&#x27;Los Angeles&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在未启用索引下推时，InnoDB 存储引擎仅依据 age &gt; 30 的索引范围扫描收集所有符合该条件的行，并将它们一股脑儿地返回给 MySQL 服务器层，由服务器再对 <code>city = &#39;Los Angeles&#39;</code> 条件逐行筛选；而启用索引下推后，存储引擎会在索引扫描阶段同时评估 <code>age &gt; 30</code> 与 <code>city = &#39;Los Angeles&#39;</code> 两个条件，只有同时满足的行才会被送到服务器层，从而避免了无谓的行回表和服务器级过滤，显著减少了 I&#x2F;O 操作并提升了查询性能。实际执行时，若在 EXPLAIN 的 Extra 列中看到 Using index condition 即表示已启用这一优化。</p>
<h2 id="join-优化"><a href="#join-优化" class="headerlink" title="join 优化"></a>join 优化</h2><p>在实际生产环境中，为了避免子查询带来的性能瓶颈，我们通常将其改写为等价的 JOIN 操作，并让行数较少的小表首先驱动行数庞大的大表，从而缩小中间结果集，减少随机 I&#x2F;O；同时可以在业务表中适当增加冗余字段，将频繁关联的维度信息直接存储在事实表中，以降低 JOIN 次数；为控制单次查询的复杂度，通常不超过三张表联合查询，如若业务允许，还可将逻辑复杂的多表 JOIN 拆分为多个简单查询，再在应用层按需合并结果，以实现更稳定高效的查询性能。</p>
<h2 id="insert-优化"><a href="#insert-优化" class="headerlink" title="insert 优化"></a>insert 优化</h2><p>在大规模数据写入场景下，将多条记录合并到单条 INSERT 语句中（例如一次提交 500–1000 条）能显著减少网络往返与语句解析开销，性能远超逐行插入；同时，关闭 AUTOCOMMIT 并使用 <code>START TRANSACTION…COMMIT</code> 手动提交事务，可以将多次写操作合并在一次事务中，避免频繁的事务开启与提交，从而进一步提升吞吐量；对于尤其庞大的数据集，采用 <code>LOAD DATA LOCAL INFILE</code> 命令从客户端文件批量导入，可利用服务器端的高速流式加载机制，其速度通常比批量 INSERT 快一个数量级以上；最后，确保插入数据按照主键单调递增的顺序写入 InnoDB 表，可减少聚簇索引中的页分裂与随机 I&#x2F;O，获得优于乱序插入的最佳写入性能。</p>
<h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p><strong>选择简短且固定长度的整型主键</strong>：主键长度越短，聚簇索引和二级索引的存储和缓存开销越小；建议使用 INT 或 BIGINT 类型，并尽量避免使用 UUID 等无序且长度较长的值。</p>
<p><strong>采用自增（<code>AUTO_INCREMENT</code>）主键</strong>：自增主键保证插入顺序与唯一性，能够最大化页的填充率并避免频繁的页分裂；只要满足业务需求，应优先使用自增主键而非自然主键（如身份证号）。</p>
<p><strong>避免修改主键值</strong>：主键一旦更新，InnoDB 必须删除旧记录并插入新记录，等同于一次删除加一次插入，极易导致页分裂和 B+ 树重组，严重影响写入性能和存储布局。</p>
<p><strong>显式定义主键</strong>：即使表中已有唯一索引，仍应显式声明主键列；若未定义主键，InnoDB 会隐式创建一个隐藏的聚簇索引，增加不确定性，且可能浪费空间和管理成本。</p>
<h2 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h2><p>在 MySQL 中，任何无法直接利用索引有序性完成的 ORDER BY 操作都会触发 <strong>filesort</strong>：存储引擎先全表（或范围）扫描读取所有匹配行，将它们放入排序缓冲区（<code>sort_buffer</code>）中完成内存（或磁盘）排序后再返回结果；而如果能建立一个正好覆盖排序字段并且包含查询所需列的索引（<strong>Using index</strong>），MySQL 则可通过顺序扫描该索引直接输出有序结果，无需额外排序，效率更高。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> age, phone </span><br><span class="line"><span class="keyword">FROM</span> table_name </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">ASC</span>, phone <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p>若事先创建：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_age_pho_ad </span><br><span class="line"><span class="keyword">ON</span> table_name(age <span class="keyword">ASC</span>, phone <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<p>则该查询可通过索引顺序扫描直接返回，避免 filesort 和回表查询；否则，MySQL 在执行时仍需先回表取出 phone 字段，再对 age、phone 结果集进行 filesort，才能满足排序要求。对于多列排序，除了要遵循<strong>最左前缀</strong>原则以保证索引可用，还需在建索引时指定正确的 ASC&#x2F;DESC 顺序；当无法避免 filesort 时，可通过增大 <code>sort_buffer_size</code>（默认为 256 KB）来提升大数据量场景下的排序性能。</p>
<h2 id="group-by-优化"><a href="#group-by-优化" class="headerlink" title="group by 优化"></a>group by 优化</h2><p>在 MySQL 中，如果将用于 GROUP BY 的列定义在符合<strong>最左前缀</strong>规则的复合 B+Tree 索引上，服务器就可以直接沿着索引的有序叶节点执行分组操作，而无需使用临时表或 filesort，从而显著提高聚合查询性能；例如对于 <code>GROUP BY(a, b)</code> 的场景，只要存在 <code>(a, b, …)</code> 这样的复合索引，MySQL 就能利用该索引在扫描叶节点时即完成对 (a,b) 键值的分组，而不是先拉取所有行再在服务器层排序和分组。</p>
<h2 id="limit-优化"><a href="#limit-优化" class="headerlink" title="limit 优化"></a>limit 优化</h2><p>在面对海量数据分页时，传统的 <code>LIMIT … OFFSET</code> 会因数据库必须扫描并丢弃前 OFFSET 行而导致深度分页速度骤降；为此，可采用延迟关联（Deferred Join）技术——先在子查询中仅基于主键索引完成分页，再与主表 JOIN 获取完整行，以大幅缩减扫描量并保持深度分页的稳定性能；另一种常见做法是书签或键集分页（Keyset Pagination），即在每页结果中记录最后一行的排序键，下次查询以 <code>WHERE key &gt; last_key LIMIT N</code> 的方式继续，既避免了昂贵的 OFFSET 跳过开销，又能直接利用索引顺序扫描；总之，通过延迟关联减少笛卡尔积运算并使用游标式或书签式分页策略，可在保持简洁 SQL 的同时显著提升大数据量分页查询的执行效率。</p>
<h2 id="count-优化"><a href="#count-优化" class="headerlink" title="count 优化"></a>count 优化</h2><p>在 MySQL 中，<code>COUNT(column)</code> 最慢，因为引擎要逐行取出指定列的值并判断是否为 NULL，只有非空值才累加；<code>COUNT(primary_key)</code> 略快一些，因为主键列本身有 NOT NULL 约束，无需判断空值即可累加；<code>COUNT(1)</code> 与 <code>COUNT(*)</code> 在现代 MySQL 中被优化为等价操作，它们都不实际读取任何列值，而是在服务层对每行隐式累加一个常量，性能十分接近，通常是最快的计数方式。</p>
<p>大多数权威测试与官方文档都表明，COUNT(1) 与 COUNT(*) 在 MySQL&#x2F;InnoDB 上几乎没有性能差异，且二者优于其他形式的 COUNT（例如 COUNT(column)）。</p>
<blockquote>
<p>[!NOTE]</p>
<p>如果我们需要在大数据量下统计唯一值，同时对处理速度要求很高，但是允许出现小幅度误差，这个时候我们可以使用 HyperLogLog 算法。</p>
<p>HyperLogLog 是一种概率算法，通过统计哈希值中最长前导零长度来估算数据基数，误差一般在 1–2% 范围内。</p>
<p>具体论文，可参考：<a target="_blank" rel="noopener" href="https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf">https://algo.inria.fr/flajolet/Publications/FlFuGaMe07.pdf</a></p>
</blockquote>
<h2 id="update-优化"><a href="#update-优化" class="headerlink" title="update 优化"></a>update 优化</h2><p>InnoDB 的行锁实际上是对索引记录（index record）加锁，而非对物理存储行本身加锁：当执行带有 WHERE 条件的 <code>UPDATE</code>、<code>DELETE</code> 或 <code>SELECT … FOR UPDATE</code> 时，InnoDB 会在匹配条件的索引叶节点上设置记录锁和必要的间隙锁，从而实现行级并发控制；但如果查询条件无法利用任何合适的索引，InnoDB 就必须扫描整个表并在聚簇索引（或隐式主键索引）上对所有记录加锁，这时就会退化为表级锁，阻塞全表写操作；同样地，若使用的索引失效（例如对非索引列做范围扫描或函数运算），也会触发锁粒度升级为表锁，导致并发性能急剧下降。因此，为了保持细粒度的行锁并避免意外的表锁锁阻塞，务必为常用的查询条件列创建合适且选择性高的索引。</p>
<h2 id="union-优化"><a href="#union-优化" class="headerlink" title="union 优化"></a>union 优化</h2><p>在使用 UNION 语句时，为了让优化器更高效地执行查询，应将共同的过滤条件（如 WHERE）和分页限制（如 LIMIT）尽可能下推到各个子查询中，这样每个子查询只需处理满足自身子集条件的行，并在各自范围内完成截取与过滤，避免先将所有子查询结果合并后再做统一筛选，从而减少中间结果集的大小、降低 I&#x2F;O 与内存开销，并加快整体查询响应速度。</p>
<p><strong>MySQL 数据库 cpu 飙升的话，要怎么处理呢？</strong></p>
<p>在 MySQL 出现 CPU 飙升时，首先可借助操作系统工具（如 top 或 htop）确认是 mysqld 进程占用过高，接着在数据库层面执行 <code>SHOW PROCESSLIST</code> 或查询 <code>information_schema.processlist</code>，快速定位执行时间或状态异常的会话，并对最耗资源的 SQL 做 EXPLAIN 分析，检查是否缺失索引或数据量过大；发现可疑线程后，可使用 KILL 语句终止它们，同时观察 CPU 是否回落，然后针对性地优化（如新增索引、重写慢查询、调整内存参数等）并重新执行这些 SQL；此外，如果是大量会话瞬间涌入导致 CPU 突增，则需与应用方协同排查连接激增的原因，并可考虑设置最大连接数或在业务层做限流，以防过多并发请求压垮数据库服务器。</p>
<p><strong>有一个查询需求，MySQL 中有两个表，一个表 1000W 数据，另一个表只有几千数据，要做一个关联查询，如何优化？</strong></p>
<p>如果 orders 表是大表（比如 1000 万条记录），而 users 表是相对较小的表（比如几千条记录）。</p>
<ol>
<li><p>为关联字段建立索引，确保两个表中用于 JOIN 操作的字段都有索引。这是最基本的优化策略，避免数据库进行全表扫描，可以大幅度减少查找匹配行的时间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_id <span class="keyword">ON</span> users(user_id);</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_user_id <span class="keyword">ON</span> orders(user_id);</span><br></pre></td></tr></table></figure>
</li>
<li><p>小表驱动大表，在执行 JOIN 操作时，先过滤小表中的数据，这样可以减少后续与大表进行 JOIN 时需要处理的数据量，从而提高查询效率。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> u.<span class="operator">*</span>, o.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> user_id</span><br><span class="line">  <span class="keyword">FROM</span> users</span><br><span class="line">  <span class="keyword">WHERE</span> some_condition <span class="comment">-- 这里是对小表进行过滤的条件</span></span><br><span class="line">) <span class="keyword">AS</span> filtered_users</span><br><span class="line"><span class="keyword">JOIN</span> orders o <span class="keyword">ON</span> filtered_users.user_id <span class="operator">=</span> o.user_id</span><br><span class="line"><span class="keyword">WHERE</span> o.some_order_condition; <span class="comment">-- 如果需要，可以进一步过滤大表</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>如何解决慢查询问题？</strong></p>
<p>首先，开启慢查询日志，用于记录执行时间超过阈值的查询，帮助定位慢查询的 SQL 语句。</p>
<p>开启方法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> slow_query_log <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> long_query_time <span class="operator">=</span> <span class="number">1</span>; <span class="comment">-- 设置慢查询的阈值为1秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;slow_query_log%&#x27;</span>; <span class="comment">-- 确认是否启用</span></span><br></pre></td></tr></table></figure>

<p>之后检查慢查询日志文件，定位耗时较长的 SQL 语句，并使用 EXPLAIN 分析 SQL 的执行计划，判断是否使用了索引或是否存在全表扫描等问题。</p>
<p>比如说：<code>EXPLAIN SELECT * FROM table_name WHERE column_name = &#39;value&#39;;</code>，该命令中的关键字段解释如下：</p>
<ol>
<li>type：查询类型，优化目标是避免 ALL（全表扫描），优先选择 index、range。</li>
<li>key：实际使用的索引。</li>
<li>rows：扫描的行数，值越小越好。</li>
<li>extra：留意 Using temporary 或 Using filesort，这些会影响性能。</li>
</ol>
<p>如果缺少索引，那么我们需要为查询条件中的字段添加索引，特别是 WHERE、JOIN、GROUP BY、ORDER BY 中涉及的字段。<br>比如说：<code>CREATE INDEX idx_column ON table_name (column_name);</code></p>
<p>如果大量数据出现回表操作，那么需要改成覆盖索引，减少回表操作。<br>比如说：<code>CREATE INDEX idx_multi_column ON table_name (column1, column2);</code></p>
<p>同时，还要判断是否出现索引失效。对此，我们可以避免对索引列使用函数或表达式，避免隐式类型转换（如字符串与数字比较）。</p>
<p>然后，我们可以重构查询语句，比如说使用 LIMIT 分页来避免返回大量数据：<code>SELECT * FROM table_name WHERE condition LIMIT 100;</code>，或者可以明确查询字段：<code>SELECT column1, column2 FROM table_name WHERE condition;</code>，避免运行 <code>SELECT *;</code>，再者可以在 JOIN 字段上设置索引，并尽量减少复杂的嵌套查询。</p>
<p>最后，我们可以进行表结构优化。</p>
<p>比如说可以使用分区表，也就是如果查询条件中经常使用时间或地理区域，可以将表按这些字段分区，减少扫描范围：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> table_name (</span><br><span class="line">  id <span class="type">BIGINT</span> <span class="keyword">NOT NULL</span>,</span><br><span class="line">  created_at <span class="type">DATE</span> <span class="keyword">NOT NULL</span></span><br><span class="line">) <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">YEAR</span>(created_at)) (</span><br><span class="line">  <span class="keyword">PARTITION</span> p2023 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2024</span>),</span><br><span class="line">  <span class="keyword">PARTITION</span> p2024 <span class="keyword">VALUES</span> LESS THAN (<span class="number">2025</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>或者如果单表数据量仍然过大，还可以按特定规则（如用户 ID）将表拆分为多个子表，降低单表数据量。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Yihang Wei</p>
  <div class="site-description" itemprop="description">聚焦于个人的学习与成长历程，旨在系统记录在后端开发、数据库等领域的探索与实践。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="">
      
        <option value="zh-CN" data-href="/page/5/index.html" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/page/5/index.html" selected="">
          English
        </option>
      
    </select>
  </div>

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yihang Wei</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>

<script>
var options = {
  bottom: '50%',
  right: '32px',
  left: 'unset',
  time: '0.5s',
  mixColor: '#fff',
  backgroundColor: '#fff',
  buttonColorDark: '#100f2c',
  buttonColorLight: '#fff',
  saveInCookies: true,
  label: '明暗',
  autoMatchOsTheme: true
}
const darkmode = new Darkmode(options);
window.darkmode = darkmode;
darkmode.showWidget();
</script>

</body>
</html>
